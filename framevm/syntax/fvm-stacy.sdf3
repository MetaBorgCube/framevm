module fvm-stacy

imports
	fvm-common
  
sorts Body context-free syntax
  SBlock.STC_Block = <<lbl:BlockLabel>:
    <size:CFSSize?>
    <ret:SOnReturnInstr?>
    <instr:SInstr*> 
    <jump:SControlInstr>

> { layout (indent lbl size && align-list instr && align instr jump && align ret instr && align size ret) }
  
sorts SInstr context-free syntax
  SInstr.STC_Print       = <print>                 // Prints value on the stack
  SInstr.STC_PrintChar   = <printc>                // Prints character on the stack
  SInstr.STC_Debug       = <debug>                 // Prints the state of the vm
  SInstr.STC_DebugKill   = <debug!>                // Prints the state of the vm and kills execution
  SInstr.STC_REq         = <eqr>                   // Check whether two references are equal
  
  
  SInstr = SIntInstr
  SIntInstr.STC_IPush  = <ipush <INT>>             // Push int value to stack
  SIntInstr.STC_INeg   = <negi>                    // Negates the integer on top of the stack
  SIntInstr.STC_IAdd   = <addi>                    // Consumes two ints from stack and adds them, result is stored on stack
  SIntInstr.STC_IMul   = <muli>                    // Consumes two ints from stack and multilpies them, result is stored on stack
  SIntInstr.STC_ISub   = <subi>                    // Consumes two ints from stack and subtracts them, result is stored on stack
  SIntInstr.STC_IDiv   = <divi>                    // Consumes two ints from stack and divides them, result is stored on stack
  SIntInstr.STC_IMod   = <modi>                    // Consumes two ints from stack and mods them, result is stored on stack
  
  SIntInstr.STC_IEq    = <eqi>                     // Consumes two ints from stack and equals them, result is stored on stack
  SIntInstr.STC_ILt    = <lti>                     // Consumes two ints from stack and performs < on them, result is stored on stack
  SIntInstr.STC_IGt    = <gti>                     // Consumes two ints from stack and performs > on them, result is stored on stack
  SIntInstr.STC_IOr    = <ori>                     // Consumes two ints from stack and performs binary or on them, result is stored on stack
  SIntInstr.STC_IXor   = <xori>                    // Consumes two ints from stack and performs binary xor on them, result is stored on stack
  SIntInstr.STC_IAnd   = <andi>                    // Consumes two ints from stack and performs binary and on them, result is stored on stack
  
  
  SInstr = SStackInstr
  SStackInstr.STC_Pop    = <pop>                   // Discards the top value on the stack
  SStackInstr.STC_Dup    = <dup>                   // Duplicates the value on the stack
  SStackInstr.STC_DupN   = <dup <INTLZ>>           // Duplicates the n-th value on the stack
  SStackInstr.STC_Swap   = <swap>                  // Swaps two values on the stack
  SStackInstr.STC_SwapN  = <swap <INTLZ>>          // Swaps the value on top of the stack with the one in (n+1)th position
    
  SInstr = STypeInstr
  STypeInstr.STC_IsInt   = <int?>                  // Check if the element on top of the stack is an integer
  STypeInstr.STC_IsCont  = <cont?>                 // Check if the element on top of the stack is a continuation
  STypeInstr.STC_IsFrame = <frame?>                // Check if the element on top of the stack is a data frame
  STypeInstr.STC_IsClos  = <closure?>              // Check if the element on top of the stack is a closure
  
  SInstr = SFrameInstr
  SFrameInstr.STC_New    = <new>                   // Create new frame with 0 slots and push pointer on stack
  SFrameInstr.STC_New    = <new <INTLEZ>>          // Create new frame with given amount of slots and push pointer on stack
  SFrameInstr.STC_NewR   = <newr>                  // Create new frame number of slots on top of the stackand push pointer on stack
  SFrameInstr.STC_FSize  = <size>                  // Get the size of the frame on top of the stack
  
  SFrameInstr.STC_Link   = <link <PathOrEmpty> <LinkRef>> // Link frame on stack to given location (Empty path is current frame)
  SFrameInstr.STC_LinkR  = <linkr <LinkRef>>       // Link frame on second position on the stack to the frame on top
 
  SFrameInstr.STC_Set    = <set>                   // Store value on top of stack in slot on second position of the current frame
  SFrameInstr.STC_Set    = <set <PathOrEmpty>>     // Set value on the stack at path location
  SFrameInstr.STC_SetR   = <setr>                  // Store value on top of stack in slot on second position of frame on third position
  SFrameInstr.STC_SetR   = <setr <Path>>           // Set value on the stack at path location starting in frame on stack
  SFrameInstr.STC_Get    = <get>                   // Get index on top of stack of the current frame
  SFrameInstr.STC_Get    = <get <PathOrEmpty>>     // Store value at path in the stack
  SFrameInstr.STC_GetR   = <getr>                  // Get index on top of stack in frame on second position
  SFrameInstr.STC_GetR   = <getr <PathOrEmpty>>    // Store value at path from frame on stack on stack
  
  SFrameInstr.STC_IsEmpty  = <empty?>              // Check if index on top of stack of the current frame is empty
  SFrameInstr.STC_IsEmpty  = <empty? <Path>>       // Check if slot at path is empty
  SFrameInstr.STC_IsEmptyR = <emptyr?>             // Check if index on top of stack in frame on second position is empty
  SFrameInstr.STC_IsEmptyR = <emptyr? <Path>>      // Check if slot at path in frame on top of the stack is empty
  SFrameInstr.STC_Empty    = <empty>               // Empty index on top of stack of the current frame
  SFrameInstr.STC_Empty    = <empty <Path>>        // Empty slot at path
  SFrameInstr.STC_EmptyR   = <emptyr>              // Empty index on top of stack in frame on second position
  SFrameInstr.STC_EmptyR   = <emptyr <Path>>       // Empty slot at path in frame on top of the stack
  
  
  SFrameInstr.STC_FrameCopy  = <copy <CopyPolicy>>                // Copy the current frame using the given policy
  SFrameInstr.STC_FrameCopyR = <copyr <CopyPolicy>>               // Copy the frame on top of the stack using the given policy
  SContInstr.STC_ContCopy    = <ccopy <CopyPolicy> <CopyPolicy>>  // Copy the current controlframe using the given policy
  SContInstr.STC_ContCopyR   = <ccopyr <CopyPolicy> <CopyPolicy>> // Copy the continuation on top of the stack and propagate using the given policy
  
  
  SInstr = SContInstr
  SContInstr.STC_ContThis      = <cgetcurrent>                    // Create a new continuation for the current execution point
  SContInstr.STC_ContNew       = <cnew <Label> <INTLEZ>>          // Create a continuation for a frame on the stack at a new execution point
  SContInstr.STC_ContNewR      = <cnewr <Label>>                  // Create a continuation for a frame on the stack at a new execution point
  SContInstr.STC_ContTransfer  = <transfer <INTLEZ> [<ContRef>]>  // Transfer n elements as returned values to the given continuation
  SContInstr.STC_ContTransfer  = <transfer <INTLEZ>>              // Transfer n elements as returned values to the continuation on top of the stack
  SContInstr.STC_ContTransfer  = <transfer>                       // Transfer one element as returned value to the continuation on top of the stack
  
  SOnReturnInstr.STC_ContRGetN = <rget <INTLEZ>>                  // Get n returned values onto the stack
  SOnReturnInstr.STC_ContRGet  = <rget>                           // Get a return value on the stack
  
  SContInstr.STC_ContSet       = <cset>                           // Store the value on top of the stack in the slot with id on second position
  SContInstr.STC_ContSet       = <cset [<ContRef>]>               // Store the value on top of the stack in the given slot
  SContInstr.STC_ContSetR      = <csetr>                          // Store the value on top of the stack in the slot with id on second position of the continuarioin on third position
  SContInstr.STC_ContSetR      = <csetr [<ContRef>]>              // Store the value on top of the stack in the given slot of the continuarioin on second position
  SContInstr.STC_ContGet       = <cget>                           // Get the continuation from the slot with id on top of the stack
  SContInstr.STC_ContGet       = <cget [<ContRef>]>               // Get the continuation from the given slot
  SContInstr.STC_ContGetR      = <cgetr>                          // Get the continuation from the slot with id on top of the stack from the continuation on second position
  SContInstr.STC_ContGetR      = <cgetr [<ContRef>]>              // Get the continuation from the given slot from the continuation on top of the stack
   SContInstr.STC_ClosUnpack   = <cunpack>                        // Get the dataframe of the closure on top of the stack
 
  
  SControlInstr.STC_Return     = <return>                         // Return the calue on top of the stack
  SControlInstr.STC_ReturnN    = <return <INTLEZ>>                // Return n values
  SControlInstr.STC_Yield      = <yield <Label>>                  // Yield a value and the current continuation
  SControlInstr.STC_JumpZ      = <jumpz <Label> <Label>>          // Jump to first label if stack zero, else jump to other label
  SControlInstr.STC_Jump       = <jump <Label>>                   // Unconditional jump to LABEL
  SControlInstr.STC_Call       = <call <Label> <Label>>           // Call block LABEL, using frame on the stack
  SControlInstr.STC_Call       = <call <Label>>                   // Call continuation on the stack with new block
  SControlInstr.STC_TailCall   = <tailcall <Label>>               // Tail-call block LABEL, using frame on the stack
  SControlInstr.STC_TailCall   = <tailcall>                       // Tail-call continuation on the stack
  SControlInstr.STC_ContCall   = <ccall <Label>>                  // Call a continuation
  SControlInstr.STC_ContCall   = <ccall [<ContRef>] <Label>>      // Call the given continuation
  SControlInstr.STC_ContReturn = <cret [<ContRef>]>               // Call the given continuation
  SControlInstr.STC_ContReturn = <cret>                           // Call the continuation on top of the stack
  
  SControlInstr.STC_Try        = <try <Label> <Label> <Label>>    // Execute the frame on second position on the stack and set the first frame as exception handler
  SControlInstr.STC_Try        = <try <Label>>                    // Execute the continuation on second position on the stack and set the first continuation as exception handler
  SControlInstr.STC_Throw      = <throw>                          // Throw the element on top of the stack to the exception handler
  
  SFrameInstr.STC_ScopeExit    = <exitscope <PathOrEmpty>>               // Set the frame at path as the current frame
  SControlInstr.STC_ScopeExit  = <exitscope <PathOrEmpty> <Label>>       // Break execution to a higher scope
  SFrameInstr.STC_ScopeNew     = <newscope <LinkRef>>             // Set the current frame
  SControlInstr.STC_ScopeNew   = <newscope <LinkRef> <Label>>     // Move execution to another scope and copy over the current continuation
  SFrameInstr.STC_ScopeSetCurrent = <mkcurrent>                   // Set the frame on top of the stack as the current dataframe
  SFrameInstr.STC_ScopeGetCurrent = <getcurrent>                  // Get the current dataframe

  SInstr = SClosInstr
  SClosInstr.STC_ClosNew      = <newc <CopyPolicy> <Label> <INTLEZ>> // Create a new closure form the frame on top of the stack and the given label. Use the given copy policy
  SClosInstr.STC_ClosNew      = <newc <Label> <INTLEZ>>           // Create a new closure form the frame on top of the stack and the given label. Uses shallow copy
  SClosInstr.STC_ClosToCont   = <cnew>                            // Create a continuation from a closure
  
  SInstr.STC_StringPush       = <spush <STRING>>                  // Push a string on the stack
  SInstr.STC_CharPush         = <cpush <CHAR>>                    // Push a character value to stack
  