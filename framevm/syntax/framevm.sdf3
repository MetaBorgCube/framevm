module framevm

imports Common pseudo

context-free start-symbols Program

sorts Program context-free syntax
  Program.FVM_Program = body:Block*	{ layout (align-list body) }
  
  Label.FVM_Label = LABEL
  
sorts Block context-free syntax

  Block.FVM_Block = <
<lbl:Label>: 
    <body:Body>

> 			{ layout (indent lbl body) }
  
  Block.FVM_PseudoCode = <{ 
  	<body:PsdBody>
}

> 			{ layout (indent "{" body && align "{" "}") }
  
  Body.FVM_SeqJump = <<instr:Instr*> 
<jump:ControlInstr>
>			{ layout (align-list instr && align instr jump) }
  
sorts Instr context-free syntax
  
  Instr = IntInstr
  IntInstr.FVM_IPush  = <ipush <INT>>			// Push int value to stack
  IntInstr.FVM_IAdd   = <addi>					// Consumes two ints from stack and adds them, result is stored on stack
  IntInstr.FVM_IMul   = <muli>					// Consumes two ints from stack and multilpies them, result is stored on stack
  IntInstr.FVM_ISub   = <subi>					// Consumes two ints from stack and subtracts them, result is stored on stack
  IntInstr.FVM_IDiv   = <divi>					// Consumes two ints from stack and divides them, result is stored on stack
  IntInstr.FVM_IMod   = <modi>					// Consumes two ints from stack and mods them, result is stored on stack
  
  IntInstr.FVM_IEq 	  = <eqi>					// Consumes two ints from stack and equals them, result is stored on stack
  IntInstr.FVM_ILt 	  = <lti>					// Consumes two ints from stack and performs < on them, result is stored on stack
  IntInstr.FVM_IGt    = <gti>					// Consumes two ints from stack and performs > on them, result is stored on stack
  IntInstr.FVM_IOr    = <ori>					// Consumes two ints from stack and performs binary or on them, result is stored on stack
  IntInstr.FVM_IXor   = <xori>					// Consumes two ints from stack and performs binary xor on them, result is stored on stack
  IntInstr.FVM_IAnd   = <andi>					// Consumes two ints from stack and performs binary and on them, result is stored on stack
  
  Instr.FVM_Pop      = <pop>					// Discards the top value on the stack
  Instr.FVM_Dup      = <dup>					// Duplicates the value on the stack
  Instr.FVM_DupN     = <dup <INTLZ>>			// Duplicates the n-th value on the stack
  Instr.FVM_Swap     = <swap>					// Swaps two values on the stack
  Instr.FVM_SwapN    = <swap <INTLZ>>			// Swaps the value on top of the stack with the one in (n+1)th position
  Instr.FVM_Print    = <print>					// Prints value on the stack
  Instr.FVM_Debug    = <debug>					// Prints the state of the vm
  
  
  Instr = FrameInstr
  FrameInstr.FVM_New    = <new>					// Create new frame and push pointer on stack
  FrameInstr.FVM_Link   = <link <Path> <LinkRef>> // Link frame on stack to given location (Empty path is current frame)
  FrameInstr.FVM_LinkR	= <linkr <LinkRef>>		// Link frame on second position on the stack to the frame on top
  FrameInstr.FVM_Set    = <set>					// Store value on top of stack in slot on second position of the current frame
  FrameInstr.FVM_Set    = <set <Path>>			// Set value on the stack at path location
  FrameInstr.FVM_SetR   = <setr>				// Store value on top of stack in slot on second position of frame on third position
  FrameInstr.FVM_SetR   = <setr <Path>>			// Set value on the stack at path location starting in frame on stack
  FrameInstr.FVM_Get    = <get>					// Get index on top of stack of the current frame
  FrameInstr.FVM_Get    = <get <Path>>			// Store value at path in the stack
  FrameInstr.FVM_GetR   = <getr>				// Get index on top of stack in frame on second position
  FrameInstr.FVM_GetR   = <getr <Path>>			// Store value at path from frame on stack on stack
  FrameInstr.FVM_Copy   = <copy>				// Copy the current frame
  FrameInstr.FVM_CopyR  = <copyr>				// Copy the frame on top of the stack
  
  
  Instr = ContInstr
  ContInstr.FVM_ContNew    = <cnew>  			// Create a new continuation for the current execution point
  ContInstr.FVM_ContNew    = <cnew <Label>> 	// Create a continuation of the current frame at a new execution point
  ContInstr.FVM_ContNewR   = <cnewr <Label>>  	// Create a continuation for a frame on the stack at a new execution point
  ContInstr.FVM_ContUnpack = <cunpack>			// Get the execution frame from a continuation
  
  ControlInstr.FVM_Return    = <return>					// Takes return address from opstack and copies top of stack to caller stack  
  ControlInstr.FVM_JumpZ     = <jumpz <Label> <Label>>	// Jump to first label if stack zero, else jump to other label
  ControlInstr.FVM_Jump      = <jump <Label>>			// Unconditional jump to LABEL
  ControlInstr.FVM_Call      = <call <Label> <Label>>	// Call block LABEL, using frame on the stack
  ControlInstr.FVM_Call      = <call <Label>>			// Call continuation on the stack with new block
  ControlInstr.FVM_ContCall  = <ccall>					// Call a continuation
  
  ControlInstr.FVM_Try       = <try <Label> <Label>>	// Execute the frame on second position on the stack and set the first frame as exception handler
  ControlInstr.FVM_Try       = <try>					// Execute the continuation on second position on the stack and set the first continuation as exception handler
  ControlInstr.FVM_Throw     = <throw>					// Throw the element on top of the stack to the exception handler
  
  ControlInstr.FVM_ScopeUp   = <scopeup <Path> <Label>>	// Break execution to a higher scope
  ControlInstr.FVM_ScopeDown = <scopedown <Label>>		// Move execution to another scope and copy over the current continuation
  
  Path.FVM_Self  = <[]>
  Path.FVM_Path  = <[<PathTerminal>]>
  Path.FVM_Path  = <[<{PathRef ","}+>, <PathTerminal>]>
  
  PathRef = SlotRef
  PathRef = LinkRef
  
  SlotRef.FVM_Slot = INTLEZ
  SlotRef.FVM_SlotR = <r>
  LinkRef.FVM_Link = LABEL
  LinkRef.FVM_LinkIdx = <_l<INTLEZ>>
  
  PathTerminal = PathRef
  PathTerminal = ContRef
  
  ContRef.FVM_Cont = CONTSLOT		// The continuation slots can never be a frame, so cannot be a path intermediate
  ContRef.FVM_ContIdx = <_c<INTLEZ>>
  

  
/* 

Values 

CodeV
- jump
- return 
- ...

IntV
- add
- pushi
- jumpz

BoolV
- true, false
- and 
- or

FrameRefV
- new
- set
- get 

closure =

Frame with code pointer + reference pointer

*/
  
/*

initialization of frame slots / soundness 

distinction between frame links and reference edges to frames 

well-formedness properties of instructions?

e.g. clean operand stack

*/