module framevm

imports Common pseudo

context-free start-symbols Program

sorts Program context-free syntax
  Program.Program = body:Block*	{ layout (align-list body) }
  
  Label.Label = LABEL
  Label.Label = MAIN
  
sorts Block context-free syntax

  Block.Block = <
<lbl:Label>: 
    <body:Body>

> 			{ layout (indent lbl body) }
  
  Block.PseudoCode = <{ 
  	<body:PsdBody>
}

> 			{ layout (indent "{" body && align "{" "}") }
  
  Body.Empty = 
  Body.SeqJump = <<instr:Instr*> 
<jump:ControlInstr>
>			{ layout (align-list instr && align instr jump) }
  
sorts Instr context-free syntax
  
  Instr.IAdd 	 = <addi>					// Consumes two ints from stack and adds them, result is stored on stack
  Instr.IEq 	 = <eqi>					// Consumes two ints from stack and equals them, result is stored on stack
  Instr.ILt 	 = <lti>					// Consumes two ints from stack and performs < on them, result is stored on stack
  Instr.IPush 	 = <ipush <INT>>			// Push int value to stack
  
  Instr.Dup      = <dup>					// Duplicates the value on the stack
  Instr.Swap     = <swap>					// Swaps two values on the stack
  Instr.Print    = <print>					// Prints value on the stack
  Instr.Debug    = <debug>					// Prints the state of the vm
  
  
  Instr = FrameInstr
  FrameInstr.New      = <new>					// Create new frame and push pointer on stack
  FrameInstr.Link	  = <link <Path> <ID>>		// Link frame on stack to given location (Empty path is current frame)
  FrameInstr.LinkR	  = <linkr <ID>>			// Link frame on second position on the stack to the frame on top
  FrameInstr.Set      = <set <Path>>			// Set value on the stack at path location
  FrameInstr.SetR     = <setr <Path>>			// Set value on the stack at path location starting in frame on stack
  FrameInstr.Get      = <get <Path>>			// Store value at path in the stack
  FrameInstr.GetR     = <getr <Path>>			// Store value at path from frame on stack on stack
  
  
  Instr = ContInstr
  ContInstr.ContNew = <cnew>  
  ContInstr.ContNew = <cnew <Label>>  
  ContInstr.ContSet = <cset>
  ContInstr.ContSetR = <csetr>
  ContInstr.ContGet = <cget>
  ContInstr.ContGetR = <cgetr>
  ContInstr.ContUnpack = <cunpack>
  ContInstr.ContCall = <ccall>
  
  ControlInstr.Return    = <return>					// Takes return address from opstack and copies top of stack to caller stack  
  ControlInstr.JumpZ     = <jumpz <Label> <Label>>	// Jump to first label if stack zero, else jump to other label
  ControlInstr.Jump      = <jump <Label>>			// Unconditional jump to LABEL
  ControlInstr.Call      = <call <Label> <Label>>	// Call block LABEL, using frame on the stack
  
  ControlInstr.ScopeUp   = <scopeup <Path> <Label>>
  ControlInstr.ScopeDown = <scopedown <Label>>
  
  Path.Self  = <[]>
  Path.Path  = <[<{PathRef ","}+>]>
  PathRef.Slot = INT
  PathRef.SlotR = <r>
  PathRef.Link = LABEL

  
/* 

Values 

CodeV
- jump
- return 
- ...

IntV
- add
- pushi
- jumpz

BoolV
- true, false
- and 
- or

FrameRefV
- new
- set
- get 

closure =

Frame with code pointer + reference pointer

*/
  
/*

initialization of frame slots / soundness 

distinction between frame links and reference edges to frames 

well-formedness properties of instructions?

e.g. clean operand stack

*/