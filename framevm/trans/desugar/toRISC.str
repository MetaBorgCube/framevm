module toRISC

imports
	signatures/framevm-sig
	desugar

rules
	to-RISC-all: Program(blocks) -> Program(<map(to-RISC-all)> blocks)
	to-RISC-all: Block(lbl, Seq(body)) -> Block(lbl, Seq(body_risc))
	  where
		body_risc := <to-RISC(r-dupswap)><to-RISC(r-sget)><to-RISC(r-relative)><to-RISC(r-link)><to-RISC(r-cont)> body
  
    // Boilerplate to make the desugaring step simpler
  	to-RISC(s): x -> <foldr(![], (fpr(s) <+ idf))> x 
  	fpr(s): (e, body) -> <concat> [<s>e, body]
  	idf: (e, body) -> [e|body]
  	
  	// Link -> LinkR
	r-link: Link(path, lbl)  -> [Get(path),  LinkR(lbl)]

	// Implicit continuations to explicit continuations
	r-cont: Return() -> 
		[Get(Path([SlotC()])), ContUnpack(), Swap(), SetR(Path([SlotR()])), Get(Path([SlotC()])), ContCall()]
		
	r-cont: Call(Label(block), Label(returnAddr)) -> 
		[Dup(), ContNew(Label(returnAddr)), SetR(Path([SlotC()])), Dup(), Get(Path([SlotX()])), SetR(Path([SlotX()])), ContNewR(Label(block)), ContCall()]
	
	r-cont: Call(Label(block)) -> 
		[Dup(), ContUnpack(), Dup(), Get(Path([SlotX()])), SetR(Path([SlotX()])), ContNew(Label(block)), SetR(Path([SlotC()])), ContCall()]
	
	r-cont: ScopeDown(lbl) -> 
		[Dup(), Get(Path([SlotC()])), SetR(Path([SlotC()])), Dup(), Get(Path([SlotX()])), SetR(Path([SlotX()])), ContNewR(lbl), ContCall()]
	
	r-cont: ScopeUp(path, lbl) -> 
		[Get(path), ContNewR(lbl), ContCall()]
		
	r-cont: Try(lbl_try, lbl_catch) ->
		[Dup(), Get(Path([SlotX()])), SetR(Path([SlotX()])), Dup(), Get(Path([SlotC()])), SetR(Path([SlotC()])), ContNewR(lbl_catch), 
		DupN("2"), Swap(), SetR(Path([SlotX()])), Dup(), Get(Path([SlotC()])), SetR(Path([SlotC()])), ContNewR(lbl_try), ContCall()]
		
	r-cont: Try() ->
		[Dup(), ContUnpack(), Dup(), Get(Path([SlotX()])), SetR(Path([SlotX()])), Get(Path([SlotC()])), SetR(Path([SlotC()])), 
		DupN("2"), ContUnpack(), Swap(), SetR(Path([SlotX()])), Dup(), ContUnpack(), Get(Path([SlotC()])), SetR(Path([SlotC()])), ContCall()]
		
	r-cont: Throw() -> 
		[Get(Path([SlotX()])), ContUnpack(), Swap(), SetR(Path([SlotR()])), Get(Path([SlotX()])), ContCall()]
	
	
	
	// Continuations to relative continuations
	r-relative: ContNew(lbl) -> [Get(Self()), ContNewR(lbl)]
	
	// Get/Set unfolding to single segment paths and only relative gets/sets
	r-relative: Get() -> [Get(Self()), Swap(), GetR()]
	r-relative: Set() -> [Get(Self()), SwapN("2"), Swap(), SetR()]
	
	r-relative: Get(path) -> [Get(Self()) | <r-relative> GetR(path)]
	r-relative: GetR(Path(path)) -> <foldr(![], r-relative-get)> path
	
	r-relative: Set(Path(path)) -> <concat> [[Get(Self()) | <r-relative> GetR(Path(body))] , [Swap(), SetR(Path([last]))]]
	  where
	  	(body, last) := <split-init-last> path
	r-relative: SetR(Path(path)) -> <concat> [<r-relative> GetR(Path(body)) , [SetR(Path([last]))]]
	  where
	  	(body, last) := <split-init-last> path
	
	r-relative-get: (e, list) -> [GetR(Path([e])) | list]
	
	// Reduce relative gets and sets of slots to getR/0 and setR/0
	// I don't know why you would want to do this, but you can if you really want to
	r-sget: GetR(Path([Slot(slot_id)])) -> [IPush(slot_id), GetR()]
	r-sget: SetR(Path([Slot(slot_id)])) -> [IPush(slot_id), Swap(), SetR()]
	
	r-dupswap: Dup()  -> [DupN("1")]
	r-dupswap: Swap() -> [SwapN("1")]
	