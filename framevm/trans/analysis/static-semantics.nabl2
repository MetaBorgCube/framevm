module analysis/static-semantics

imports

  signatures/-
  
signature
    namespaces Var RModule STC_Module ModuleFunc

name resolution
  labels
    P I

  order
    D < P,
    D < I,
    I < P

  well-formedness
    P* I*

rules

  init ^ (s) := new s.
  
  [[Program(_, fname, imports, size, a, blocks) ^(s)]] :=
    new prog,
    Map1(block)[[blocks ^(prog)]],
    
    new mod, mod ---> s,
    STC_Module{fname} <- s,
    STC_Module{fname}.blocks := blocks,
    STC_Module{fname}.imports := imports,
    STC_Module{fname} ===> mod,
    Map2(stcImport)[[imports ^(mod, prog)]].
    
  
  	
  stcImport[[FVM_Import(lib_name, funcs) ^(s, prog)]] :=
  	STC_Module{lib_name} -> s,
  	STC_Module{lib_name} |-> d | error $[Module not found: [lib_name]] @lib_name,
  	d ?===> ds,
  	Map2(libfunc)[[funcs ^(ds, prog)]].
  	
  stcImport[[FVM_ImportAs(lib_name, func_name, func_as) ^(s, prog)]] :=
  	STC_Module{lib_name} -> s,
  	STC_Module{lib_name} |-> d | error $[Module not found: [lib_name]] @lib_name,
  	d ?===> ds,
  	new ns, ns ---> ds,
  	ModuleFunc{func_name} -> ns,
  	ModuleFunc{func_name} |-> d2 | error $[Function not found: [func_name]] @func_name,
  	d2.label := lbl,
  	d2.lib := lib,
  	ModuleFunc{func_as} <- prog,
  	ModuleFunc{func_as}.label := lbl,
  	ModuleFunc{func_as}.lib   := lib.
  
  stcImport[[FVM_Export(lib, Local(lbl), func_as) ^(mod, prog)]] :=
  	ModuleFunc{func_as} <- mod,
  	ModuleFunc{func_as}.label := lbl,
  	ModuleFunc{func_as}.lib   := lib,
  	lbl[[lbl ^(prog)]].
  
  stcImport[[FVM_Export(_, External(name), func_as) ^(mod, prog)]] :=
  	ModuleFunc{name} -> prog,
  	ModuleFunc{name} |-> d | error $[Function not found: [name]] @name,
  	d.label := lbl,
  	d.lib   := lib,
  	
  	ModuleFunc{func_as} <- mod,
  	ModuleFunc{func_as}.label := lbl,
  	ModuleFunc{func_as}.lib   := lib.
  	
  libfunc[[func_name ^(ds, s)]] :=
  	new ns, ns ---> ds,
  	ModuleFunc{func_name} -> ns,
  	ModuleFunc{func_name} |-> d | error $[Function not found: [func_name]] @func_name,
  	d.label := lbl,
  	d.lib := lib,
  	ModuleFunc{func_name} <- s,
  	ModuleFunc{func_name}.label := lbl,
  	ModuleFunc{func_name}.lib := lib.
  	
  	
  	
  block[[FVM_Block(FVM_Label(name), FVM_Seq(body), size) ^(s)]] :=
    new block, 
    Block{name} <- s,
    distinct/name D(s)/Block | error $[Redefinition of label] @name,
    Block{name} ===> block,
    block ---> s,
    Map1(instr)[[body ^(block)]],
    size == 0 | warning $[Stack delta is non-zero: [size]] @name.
  
  lbl[[FVM_ExternalLabel(name) ^(s)]] :=
    ModuleFunc{name} -> s,
    ModuleFunc{name} |-> d | error $[Unknown imported function [name]] @name.
      
  lbl[[FVM_Label(name) ^(s)]] := lbl[[name^(s)]].
  lbl[[name ^(s)]] :=
    Block{name} -> s,
    Block{name} |-> d | error $[Unknown jump label [name]] @name.
    
      
  bind[[Bind(name, idx) ^(s)]] :=
    idx != -1 | error $[Unbound identifier [name]] @name.
      
  bind[[FVM_Path(path) ^(s)]] :=
    Map1(bind)[[path ^(s)]].
 
  bind[[FVM_Self() ^(s)]].
  bind[[FVM_Link(link) ^(s)]] :=
    bind[[link ^(s)]].
  bind[[FVM_Cont(cont) ^(s)]] :=
    bind[[cont ^(s)]].
  bind[[FVM_Slot(slot) ^(s)]].
      
      

  instr[[STC_CharPush(_) ^(s)]].
  instr[[STC_IPush(_) ^(s)]].
  instr[[STC_INeg() ^(s)]].
  instr[[STC_IAdd() ^(s)]].
  instr[[STC_ISub() ^(s)]].
  instr[[STC_IMul() ^(s)]].
  instr[[STC_IDiv() ^(s)]].
  instr[[STC_IMod() ^(s)]].

  instr[[STC_IEq() ^(s)]].
  instr[[STC_ILt() ^(s)]].
  instr[[STC_IGt() ^(s)]].
  instr[[STC_IOr() ^(s)]].
  instr[[STC_IXor() ^(s)]].
  instr[[STC_IAnd() ^(s)]].

  instr[[STC_Pop() ^(s)]].
  instr[[STC_Dup() ^(s)]].
  instr[[STC_DupN(_) ^(s)]].

  instr[[STC_Swap() ^(s)]].
  instr[[STC_SwapN(_) ^(s)]].

  instr[[STC_Print() ^(s)]].
  instr[[STC_PrintChar() ^(s)]].
  instr[[STC_Debug() ^(s)]].
  instr[[STC_DebugKill() ^(s)]].
  

  instr[[STC_FSize() ^(s)]].
  instr[[STC_New(_) ^(s)]].
  instr[[STC_New() ^(s)]].
  instr[[STC_NewR() ^(s)]].

  instr[[STC_Set() ^(s)]].
  instr[[STC_Set(path) ^(s)]]  := bind[[path ^(s)]].
  instr[[STC_SetR() ^(s)]].
  instr[[STC_SetR(path) ^(s)]] := bind[[path ^(s)]].
  instr[[STC_Get() ^(s)]].
  instr[[STC_Get(path) ^(s)]]  := bind[[path ^(s)]].
  instr[[STC_GetR() ^(s)]].
  instr[[STC_GetR(path) ^(s)]] := bind[[path ^(s)]].

  instr[[STC_ContSet() ^(s)]].
  instr[[STC_ContSet(path) ^(s)]]  := bind[[path ^(s)]].
  instr[[STC_ContSetR() ^(s)]].
  instr[[STC_ContSetR(path) ^(s)]] := bind[[path ^(s)]].
  instr[[STC_ContGet() ^(s)]].
  instr[[STC_ContGet(path) ^(s)]]  := bind[[path ^(s)]].
  instr[[STC_ContGetR() ^(s)]].
  instr[[STC_ContGetR(path) ^(s)]] := bind[[path ^(s)]].

  instr[[STC_ContTransfer(n) ^(s)]].
  instr[[STC_ContTransfer(n, path) ^(s)]] := bind[[path ^(s)]].

  instr[[STC_ContRGetN(n) ^(s)]].
  instr[[STC_ContRGet() ^(s)]].

  instr[[STC_Return() ^(s)]].
  instr[[STC_Throw() ^(s)]].

  instr[[STC_Link(bind1, bind2) ^(s)]] := bind[[bind1 ^(s)]], bind[[bind2 ^(s)]].
  instr[[STC_LinkR(bind) ^(s)]] := bind[[bind ^(s)]].

  instr[[STC_ContCopy( policy1, policy2) ^(s)]] := policy1 == policy2 | note $[Are you sure? This unlinks the references to the heap from the copied heap].
  instr[[STC_ContCopyR(policy1, policy2) ^(s)]] := policy1 == policy2 | note $[Are you sure? This unlinks the references to the heap from the copied heap].
  instr[[STC_FrameCopy(_) ^(s)]].
  instr[[STC_FrameCopyR(_) ^(s)]].

  instr[[STC_IsInt() ^(s)]].
  instr[[STC_IsCont() ^(s)]].
  instr[[STC_IsFrame() ^(s)]].
  instr[[STC_IsClos() ^(s)]].


  instr[[STC_ContThis() ^(s)]].
  instr[[STC_ContNew(lbl, _) ^(s)]] := lbl[[lbl ^(s)]].
  instr[[STC_Yield(lbl) ^(s)]] := lbl[[lbl ^(s)]].
  instr[[STC_ContCall(lbl) ^(s)]] := lbl[[lbl ^(s)]].
  instr[[STC_ContCall(path, lbl) ^(s)]] := lbl[[lbl ^(s)]], bind[[path ^(s)]].
  instr[[STC_ContReturn(path) ^(s)]] := bind[[path ^(s)]].
  instr[[STC_ContReturn() ^(s)]].
    
  instr[[STC_Jump(lbl) ^(s)]]             := lbl[[lbl ^(s)]].
  instr[[STC_JumpZ(lbl1, lbl2) ^(s)]]     := lbl[[lbl1 ^(s)]], lbl[[lbl2 ^(s)]].
  instr[[STC_Call(lbl) ^(s)]]             := lbl[[lbl ^(s)]].
  instr[[STC_Call(lbl1, lbl2) ^(s)]]      := lbl[[lbl1 ^(s)]], lbl[[lbl2 ^(s)]].
  instr[[STC_Try(lbl1, lbl2, lbl3) ^(s)]] := lbl[[lbl1 ^(s)]], lbl[[lbl2 ^(s)]], lbl[[lbl3 ^(s)]].
  instr[[STC_Try(lbl) ^(s)]]              := lbl[[lbl ^(s)]].
  instr[[STC_TailCall() ^(s)]].
  instr[[STC_TailCall(lbl) ^(s)]]         := lbl[[lbl ^(s)]].
    
  instr[[STC_ScopeNew(bind, lbl) ^(s)]]  := lbl[[lbl ^(s)]], bind[[bind ^(s)]].
  instr[[STC_ScopeNew(bind) ^(s)]]       := bind[[bind ^(s)]].
  instr[[STC_ScopeSetCurrent() ^(s)]].
  instr[[STC_ScopeExit(bind) ^(s)]]      := bind[[bind ^(s)]].
  instr[[STC_ScopeExit(bind, lbl) ^(s)]] := bind[[bind ^(s)]], lbl[[lbl ^(s)]].
  
  instr[[STC_ClosNew(_, lbl) ^(s)]] := lbl[[lbl ^(s)]].
  instr[[STC_ClosNew(lbl) ^(s)]]    := lbl[[lbl ^(s)]].
  instr[[STC_ClosToCont(_) ^(s)]].
  instr[[STC_ClosUnpack() ^(s)]].
    
  instr[[STC_StringPush(_) ^(s)]].
