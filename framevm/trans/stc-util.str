module stc-util

imports
    nabl2/api
  
    signatures/fvm-stacy-sig
    signatures/framevm-sig
    signatures/fvm-common-sig
    fvm-common
    fvm-desugar

rules
    
    // Convert a flat list of instructions to a VM program
    // Blocks are separated by labels instead of actual blocks
    // Sugar is re-added to make it printable
    stc-from-flat: (h@FVM_Header(items), [lbl@FVM_Label(_) | body]) -> <resugar> <split-header> STC_Program(h, None(), blocks)
      with
        (blocks, []) := <foldr(!([], []), from-flat-fold)> [lbl | body]
        
    stc-from-flat: (h@FVM_Header(items), [f|body]) -> <stc-from-flat> (h, [FVM_Label("MAIN"), f | body])
      with
        <not(?(FVM_Label(_)))> f
        
    stc-from-flat: body -> <stc-from-flat> (FVM_Header([]), body) with <is-list> body
   
   
    // Convert the path from an nabl2 lookup to one that can be interpreted by the VM  
    framevm-path-from-nabl2: (name, namespace, property) -> FVM_Path(fvm_path)
      where
        a            := <nabl2-get-ast-analysis> name;
        ref-occ      := <nabl2-mk-occurrence(|namespace)> name;
        (dec-occ, path) := <nabl2-get-resolved-name(|a)> ref-occ;
        idx          := <nabl2-get-property(|a, property)> dec-occ;
        (path_body, path_end) := <split-init-last> path;
        
//        TODO: Do something with the path
        fvm_path     := <concat>[<map(from-nabl2-path)> path_body, [FVM_Slot(<int-to-string> idx)]]
    
    
    from-nabl2-path: E(scope, lbl) -> FVM_Link(<get-constructor> lbl)
    
    // If the current instruction is a label, close the block (we are going bottom to top)
    // Else just store the instruction and continue
    from-flat-fold: (FVM_Label(lbl), (blocks, instrs)) -> ([FVM_Block(FVM_Label(lbl), FVM_Seq(instrs), 0) | blocks], [])
    from-flat-fold: (instr, (blocks, instrs)) -> (blocks, [instr | instrs])
