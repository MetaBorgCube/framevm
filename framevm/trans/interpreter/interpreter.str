module interpreter

imports 
    signatures/fvm-stacy-sig
    signatures/fvm-common-sig
    interpreter/stacy/-
    interpreter/roger/-
    interpreter/external
    
    fvm-common
    nabl2/api
  
signature
  sorts S
  constructors
    Program: STRING * [Import] * INT * STRING * [Alias] * [STC_Block] -> S  

rules
    eval-program-debug = eval-program(debug-eval)
    debug-eval: t@(e, _) -> t
      where <strip-annos; debug(!"execute: ")> e
      
    eval-program = eval-program(id)
    
    eval-program(s): STC_Program(fn, i, size, block, links, blocks) -> <eval-program-(s, stc-eval | "STC")> (Program(fn, i, size, block, links, blocks), <vm-init-stc> (<length> links, 2, size))
    eval-program(s): RGR_Program(fn, i, size, block, links, blocks) -> <eval-program-(s, rgr-eval | "RGR")> (Program(fn, i, size, block, links, blocks), <vm-init-rgr> (<length> links, 2, size))
    
    
    
    eval-program-(s, mode-eval | mode): (Program(fn, i, s, block, links, blocks), env1) -> out
      where 
        <gti> (<string-length> fn, 1);
        blocks' := <resolve-jump-labels(|fn)> blocks;

        (_, env2) := <foldl(store-block)> (blocks', (fn, env1));
        (_, env3) := <store-block> (FVM_Block(FVM_Label("_exit"),  None(), FVM_Seq([]), 0), (fn, env2));
        (_, env4) := <store-block> (FVM_Block(FVM_Label("_catch"), None(), FVM_Seq([]), 0), (fn, env3));
        env5 := <foldl(import-blocks(|mode))> (i, env4);
        (init_block, size) := <get-block-size> block;
        env6 := <vm-start(|env5)> (fn, init_block, size);
        env7 := <fvm-execute(s, mode-eval|env6)>;
        out  := <vm-stop(|env7)>
    
    eval-program-(s, mode-eval | mode): _ -> "FAIL"
    
    
    store-block: (FVM_Block(FVM_Label(lbl), _, FVM_Seq(body), _), (lib, env)) -> (lib, <vm-store-block(|env)> ((lib, lbl), body))
    
    import-blocks(|mode): (FVM_Import(lib, _), env1) -> env3
      where 
        (imports, blocks) := <resolve-jump-labels(|lib)> <get-lib-blocks(|mode)> lib;
        (_, env2) := <foldl(store-block)> (blocks, (lib, env1));
        env3 := <foldl(try-load-import(|mode))> (imports, env2)
        
    import-blocks(|mode): (FVM_ImportAs(lib, _, _), env1) -> env2
      where 
        (imports, blocks) := <resolve-jump-labels(|lib)> <get-lib-blocks(|mode)> lib;
        (_, env2) := <foldl(store-block)> (blocks, (lib, env1));
        env3 := <foldl(try-load-import(|mode))> (imports, env2)
        
    import-blocks(|mode): (FVM_Export(_, _, _), env) -> env
    
    try-load-import(|mode): i@(FVM_ImportAs(lib, _, _), env1) -> env2
      where
        <not(vm-has-lib(|env1))> lib;
        env2 := <import-blocks(|mode)> i
    
    try-load-import(|mode): i@(FVM_Import(lib, _), env1) -> env2
      where
        <not(vm-has-lib(|env1))> lib;
        env2 := <import-blocks(|mode)> i
    
    try-load-import(|mode): (_, env) -> env
    
    
    
    get-lib-blocks(|mode): libname -> (imports, blocks)
      where
        a            := <nabl2-get-ast-analysis> libname;
        ref-occ      := <nabl2-mk-occurrence(|$[[mode]_Module])> libname;
        (dec-occ, path) := <nabl2-get-resolved-name(|a)> ref-occ;
        blocks          := <nabl2-get-property(|a, "blocks")>  dec-occ;
        imports         := <nabl2-get-property(|a, "imports")> dec-occ
    get-lib-blocks: libname -> <fail> where <debug> $[Failed to load [libname]]
    
    resolve-jump-labels(|lib): (imports, blocks) -> (imports, <resolve-jump-labels(|lib)> blocks)
    resolve-jump-labels(|lib): [] -> []
    resolve-jump-labels(|lib): [FVM_Block(lbl, s, FVM_Seq(body), d) | t] -> [FVM_Block(lbl, s, FVM_Seq(body'), d) | <resolve-jump-labels(|lib)> t]
      where
        body' := <bottomup(try(resolve-jump-labels-(|lib)))> body
    
    get-block-size: b@FVM_InitBlock(name) -> (name, size)
      where
        a            := <nabl2-get-ast-analysis> b;
        ref-occ      := <nabl2-mk-occurrence(|"Block")> name;
        (dec-occ, _) := <nabl2-get-resolved-name(|a)> ref-occ;
        Some(size)   := <get-size(|a)> dec-occ
        
    get-block-size: FVM_InitBlock(name) -> <debug; fail> $[Block [name] not found]
    
    resolve-jump-labels-(|lib): l@FVM_Label(lbl) -> FVM_BoundLabel(lib, lbl, size)
      where
        a            := <nabl2-get-ast-analysis> l;
        ref-occ      := <nabl2-mk-occurrence(|"Block")> lbl;
        (dec-occ, _) := <nabl2-get-resolved-name(|a)> ref-occ;
        size         := <get-size(|a)> dec-occ
    
    resolve-jump-labels-(|l): FVM_ExternalLabel(func_name) -> FVM_BoundLabel(lib, lbl, size)
      where
        a            := <nabl2-get-ast-analysis> func_name;
        ref-occ      := <nabl2-mk-occurrence(|"ModuleFunc")> func_name;
        (dec-occ, path) := <nabl2-get-resolved-name(|a)> ref-occ;
        lib          := <nabl2-get-property(|a, "lib")>   dec-occ;
        lbl          := <nabl2-get-property(|a, "label")> dec-occ;
        size         := <get-size(|a)> dec-occ
        
    get-size(|a): occ -> Some(size) where size := <nabl2-get-property(|a, "size")> occ
    get-size(|a): occ -> None()
    
    // Ask next instruction and evaluate it
    // Repeat until no instructions are left
    fvm-execute(s, e|env) = vm-execute(s; e <+ eval | env)

    // Instruction not implemented or execution failed
    // Catches current instructions and reports them
    eval: (instr, env) -> <fail>
      where
        <debug> ("Execution failed at instruction", <strip-annos> instr)
