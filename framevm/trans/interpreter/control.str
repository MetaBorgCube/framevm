module control

imports 
	signatures/framevm-sig
	interpreter/common
	interpreter/external
	interpreter/util
	
rules	
	
	// FVM_Call/2
	// Call the block at arg1 using the frame at the top of the stack
	// This function returns to arg2 when finished
	eval: (FVM_Call(FVM_Label(block), FVM_Label(returnAddr)), env1) -> env5
	  where
	  	(env2, FrameRef(callFrame)) := <stack-pop-frame(|env1)>;	// get the function frame
	  	(env3, func) := <vm-cont-new(|env2)> (callFrame, block, 2);
	  	
	  	cont_this := <cont-this(|env3)>;
	  	env4 := <cont-set-cc(|env2)> (func, cont_this);	// Set the return address
	  	ex := <ex-get-cx(|env3)> cont_this;
	  	env5 := <ex-set-cx(|env3)> (func, ex);						// Copy over exception
	  	env6 := <vm-jump(|env5)> returnAddr;
	  	env7 := <cont-call(|env4)> func								// call the function
	  	
	// FVM_Call/1
	// Call the continuation at the top of the stack with return to block
	eval: (FVM_Call(FVM_Label(block)), env1) -> env5
	  where
	  	(env2, func) := <stack-pop-cont(|env1)>;// get the function continuation
	  	cont_this := <cont-this(|env2)>;
	  	env3 := <cont-set-cc(|env2)> (func, cont_this);			// Set the return address
	  	ex := <ex-get-cx(|env3)> cont_this;
	  	env4 := <ex-set-cx(|env3)> (func, ex);						// Copy over exception
	  	env5 := <vm-jump(|env4)> block;
	  	env6 := <cont-call(|env5)> func								// call the function
	 
	 // FVM_Return/0
	// Takes the value on top of the stack and returns to the caller frame
	eval: (FVM_ReturnN(n), env1) -> env4
	  where
	  	(env2, vals) := <pop-list(|env1)> <string-to-int> n;
	  	continuation := <cont-get-cc(|env2)> <cont-this(|env2)>;
	  	env3 := <cont-transfer(|env2)> (continuation, vals);
	  	env4 := <cont-call(|env3)> continuation
	  	
	// FVM_ReturnN/1
	eval: (FVM_Return(), env1) -> env4
	  where
	  	(env2, val) := <stack-pop-any(|env1)>;
	  	continuation := <cont-get-cc(|env2)> <cont-this(|env2)>;
	  	env3 := <cont-transfer(|env2)> (continuation, [val]);
	  	env4 := <cont-call(|env3)> continuation
	
	// FVM_Jump/1
	// Unconditional jump to a new block ar arg1
	eval: (FVM_Jump(FVM_Label(lbl)), env1) -> env2
	  where
	  	env2 := <vm-jump(|env1)> lbl
	
	// FVM_JumpZ/2
	// Conditional jump. 
	// Checks top of the stack, when zero goes to arg1 else to arg2
	eval: (FVM_JumpZ(FVM_Label(then), FVM_Label(else)), env1) -> env3
	  where
	  	(env2, IntV(val)) := <stack-pop-int(|env1)>;
	  	trgt := <jump-eval> (val, then, else);
	  	env3 := <vm-jump(|env2)> trgt
	
	// FVM_ScopeNew/1
	// Move execution to a new scope, for example when entering a for loop
	// Uses the frame on top of the stack as new execution frame (make sure its properly linked)
	// Jumps the execution to the given block
	eval: (FVM_ScopeNew(FVM_Label(lbl)), env1) -> env4
	  where
	  	(env2, FrameRef(frame_to)) := <stack-pop-frame(|env1)>;
	  	env3 := <frame-set-current(|env2)> (<cont-this(|env2)>, frame_to);
	  	env4 := <vm-jump(|env3)> lbl

	// FVM_ScopeNew/0
	// Move execution to a new scope, for example when entering a for loop
	// Uses the frame on top of the stack as new execution frame (make sure its properly linked)
	eval: (FVM_ScopeNew(), env1) -> env3
	  where
	  	(env2, FrameRef(frame_to)) := <stack-pop-frame(|env1)>;
	  	env3 := <frame-set-current(|env2)> (<cont-this(|env2)>, frame_to)
	  	
	// Resolve which label to pick
	jump-eval: ("0", then, _) -> then
	jump-eval: ("1", _, else) -> else	// We might want to make this catch all, like in C
