module control

imports 
	signatures/framevm-sig
	interpreter/common
	
rules	
	// Call to the given continuation
	eval-call(|env1): Continuation("exit", _) -> env1	
	eval-call(|env1): Continuation(contFrame, contLabel) -> env2
	  where
	  	env2 := <vm-call(|env1)> (contFrame, contLabel)	// call the function

	// Create a new continuation of the current frame
	new-continuation(|env): addr -> Continuation(<frame-this(|env)>, addr)
	
	// Store the return value in the 'r' register of the continuation
	// If the continuation is 'exit', print the exitcodes
	set-return-val(|env1): (Continuation("exit", _), val) -> env1
	  where
	  	_ := <print-exit> val
	
	set-return-val(|env1): (Continuation(frame, _), val) -> env2
	  where
	  	env2 := <frame-set(|env1)> (frame, "r", val)
	  	
	// Print succesfull when IntV(0), print an error otherwise
	print-exit: IntV(e) -> <print-exit> e
	print-exit: "0" -> <debug> "Execution finished cleanly"
	print-exit: e -> <debug> ("Terminated with errors:", e)
	
	
	
	
	// Call/2
	// Call the block at arg1 using the frame at the top of the stack
	// This function returns to arg2 when finished
	eval: (Call(Label(block), Label(returnAddr)), env1) -> env4
	  where
	  	(env2, FrameRef(callFrame)) := <stack-pop(|env1)>;				// get the function frame
	  	continuation := <debug><new-continuation(|env2)> returnAddr;
//	  	env3 := <vm-jump(|env2)> (<frame-this(|env1)>, returnAddr);		// Prepare return location (This cannot be done in bytecode as stuff will break)
	  	env3 := <vm-set-cc(|env2)> (callFrame, continuation);			// Set the return address
	  	env4 := <eval-call(|env3)> Continuation(callFrame, block)		// call the function
	 
	// Return/0
	// Takes the value on top of the stack and returns to the caller frame
	eval: (Return(), env1) -> env4
	  where
	  	(env2, val) := <stack-pop(|env1)>;
	  	continuation := <vm-get-cc(|env2)>;
	  	env3 := <set-return-val(|env2)> (continuation, val);
	  	env4 := <eval-call(|env3)> continuation
	
	// Jump/1
	// Unconditional jump to a new block ar arg1
	eval: (Jump(Label(lbl)), env1) -> env2
	  where
	  	env2 := <vm-jump(|env1)> (<frame-this(|env1)>, lbl)
	
	// JumpZ/2
	// Conditional jump. 
	// Checks top of the stack, when zero goes to arg1 else to arg2
	eval: (JumpZ(Label(then), Label(else)), env1) -> env3
	  where
	  	(env2, IntV(val)) := <stack-pop(|env1)>;
	  	trgt := <jump-eval> (val, then, else);
	  	env3 := <vm-jump(|env2)> (<frame-this(|env2)>, trgt)
	
	// ScopeDown/1
	// Move execution to a child scope, for example when entering a for loop
	// Uses the frame on top of the stack as new execution frame (make sure its properly linked)
	// Jumps the execution to the given block
	eval: (ScopeDown(Label(lbl)), env1) -> env4
	  where
	  	(env2, FrameRef(frame_to_id)) := <stack-pop(|env1)>;
	  	env3 := <vm-set-cc(|env2)> (frame_to_id, <vm-get-cc(|env2)>);
	  	env4 := <vm-call(|env3)> (frame_to_id, lbl)

	// Resolve which label to pick
	jump-eval: ("0", then, _) -> then
	jump-eval: ("1", _, else) -> else	// We might want to make this catch all, like in C
