module frame

imports 
	signatures/framevm-sig
	interpreter/common
	interpreter/external

rules
	// FVM_New/0
	// pushes an empty frame with 0 slots on the stack
  	eval: (FVM_New(), env1) -> env3
  	  where
  	  	(env2, frame) := <frame-new(|env1)> 0;
  	  	env3 := <stack-push(|env2)> FrameRef(frame)
  	  	
	// FVM_New/1
	// pushes an empty frame with n slots on the stack
  	eval: (FVM_New(n), env1) -> env3
  	  where
  	  	(env2, frame_id) := <frame-new(|env1)> <string-to-int> n;
  	  	env3 := <stack-push(|env2)> FrameRef(frame_id)
  	  	
	// FVM_NewR/0
	// pushes an empty frame with n slots on the stack
  	eval: (FVM_NewR(), env1) -> env4
  	  where
  	  	(env2, IntV(n)) := <stack-pop-int(|env1)>;
  	  	(env3, frame_id) := <frame-new(|env2)> <string-to-int> n;
  	  	env4 := <stack-push(|env3)> FrameRef(frame_id)
  	
  	// FVM_Get/0
  	// Get index on top of stack of the current frame
  	eval: (FVM_Get(), env1) -> env3
  	  where
  	  	(env2, IntV(slot)) := <stack-pop-int(|env1)>;
  	  	env3 := <stack-push(|env2)> <frame-get> (env2, <frame-this(|env2)>, FVM_Slot(slot))
  	  	
  	// FVM_Get/1
  	// Push a value on the stack, this value is found by following arg1
  	eval: (FVM_Get(FVM_Self()), env1) -> env2
  	  where
  	  	env2 := <stack-push(|env1)> FrameRef(<frame-this(|env1)>)

  	eval: (FVM_Get(FVM_Path(p)), env1) -> env2
  	  where
  	  	(frame_id, slot) := <resolve> (p, FrameRef(<frame-this(|env1)>), env1);
  	  	env2 := <stack-push(|env1)> <frame-get> (env1, frame_id, slot)

	// FVM_Set/0
	// Store value on top of stack in slot on second position on stack of the current frame
  	eval: (FVM_Set(), env1) -> env4
  	  where
  	  	(env2, value) := <stack-pop-any(|env1)>;
  	  	(env3, IntV(slot)) := <stack-pop-int(|env2)>;
  	  	env4 := <frame-set(|env3)> (<frame-this(|env3)>, FVM_Slot(slot), value)
  	  	
	// FVM_Set/1
	// Store the value on top of the stack at the location found by traversing arg1 
  	eval: (FVM_Set(FVM_Path(p)), env1) -> env3
  	  where
  	  	(frame, slot) := <resolve> (p, FrameRef(<frame-this(|env1)>), env1);
  	  	(env2, value) := <stack-pop-any(|env1)>;
  	  	env3 := <frame-set(|env2)> (frame, slot, value)
  	  	
  	// FVM_GetR/0
  	// Get index on top of stack in frame on second position
  	eval: (FVM_GetR(), env1) -> env4
  	  where
  	  	(env2, IntV(slot)) := <stack-pop-int(|env1)>;
  	  	(env3, FrameRef(frame)) := <stack-pop-frame(|env2)>;
  	  	env4 := <stack-push(|env3)> <frame-get> (env3, frame, FVM_Slot(slot))
  	
  	// FVM_GetR/1
  	// Push a value on the stack, this value is found by 
  	// following arg1 (starting from the frame on top of the stack)
  	eval: (FVM_GetR(FVM_Self()), env1) -> env1  	// This connamd litterally does nothing
  	eval: (FVM_GetR(FVM_Path(p)), env1) -> env3
  	  where
  	  	(env2, frame) := <stack-pop-frame(|env1)>;
  	  	(frame_id, slot):= <resolve> (p, frame, env2);
  	  	env3 := <stack-push(|env2)> <frame-get> (env2, frame_id, slot)

	// FVM_SetR/0
	// Store value on top of stack in slot on second position of frame on third position
  	eval: (FVM_SetR(), env1) -> env5
  	  where
  	  	(env2, value) := <stack-pop-any(|env1)>;
  	  	(env3, IntV(slot)) := <stack-pop-int(|env2)>;
  	  	(env4, FrameRef(frame)) := <stack-pop-frame(|env3)>;
  	  	env5 := <frame-set(|env4)> (frame, FVM_Slot(slot), value)
  	
	// FVM_Setr/1
  	// Store the value on top of the stack at 
  	// the location found by traversing arg1 from the frame on second position on the stack
  	eval: (FVM_SetR(FVM_Path(p)), env1) -> env4
  	  where
  	  	(env2, value) := <stack-pop-any(|env1)>;
  	  	(env3, frame_init) := <stack-pop-frame(|env2)>;
  	  	(frame, slot) := <resolve> (p, frame_init, env1);
  	  	env4 := <frame-set(|env3)> (frame, slot, value)

	// FVM_Copy/0
	// Copy the current frame and push the copy on the stack
	eval: (FVM_Copy(), env1) -> env3
	  where
	  	(env2, copy) := <frame-copy(|env1)> <frame-this(|env1)>;
	  	env3 := <stack-push(|env2)> FrameRef(copy)
	
	// FVM_CopyR/0
	// Copy the frame on top of the stack and push the copy on the stack
	eval: (FVM_CopyR(), env1) -> env4
	  where
	  	(env2, FrameRef(frame)) := <stack-pop-frame(|env1)>;
	  	(env3, copy) := <frame-copy(|env2)> frame;
	  	env4 := <stack-push(|env2)> FrameRef(copy)
	
	// FVM_Link/2
	// Link the frame on top of the stack to the frame pointed to by arg1
	// using label arg2
	eval: (FVM_Link(FVM_Self(), FVM_Link(Bind(lbl, idx))), env1) -> env3
	  where
	  	frame_to_id := <frame-this(|env1)>;
	  	(env2, FrameRef(frame_from_id)) := <stack-pop-frame(|env1)>;
	  	env3 := <frame-link(|env2)> (frame_from_id, frame_to_id, (lbl, idx))
	  	
	eval: (FVM_Link(FVM_Path(path), FVM_Link(Bind(lbl, idx))), env1) -> env3
	  where
	  	(frame_id, slot_id) := <resolve> (path, FrameRef(<frame-this(|env1)>), env1);
	  	FrameRef(frame_to_id) := <frame-get> (env1, frame_id, slot_id);
	  	(env2, FrameRef(frame_from_id)) := <stack-pop-frame(|env1)>;
	  	env3 := <frame-link(|env2)> (frame_from_id, frame_to_id, (lbl, idx))
	  	
	// FVM_LinkR/1
	// Link the frame on 2nd position to the frame on top of the stack
	eval: (FVM_LinkR(FVM_Link(Bind(lbl, idx))), env1) -> env4
	  where
	  	(env2, FrameRef(frame_to_id)) := <stack-pop-frame(|env1)>;
	  	(env3, FrameRef(frame_from_id)) := <stack-pop-frame(|env2)>;
	  	env4 := <frame-link(|env3)> (frame_from_id, frame_to_id, (lbl, idx))
	  
	// FVM_ScopeExit/2
	// Move execution to a parent scope without actually returning
	// Can be seen as functioning like a break statement
	// Breaks to the scpoe at the provided path and move execution to the given block
	eval: (FVM_ScopeExit(FVM_Path(path), FVM_Label(lbl)), env1) -> env2
	  where
		(frame, FVM_Link(Bind(link_id, idx))) := <resolve> (path, FrameRef(<frame-this(|env1)>), env1);
		env2 := <frame-set-current(|env1)> (<cont-this(|env1)>, <frame-get-link(|env1)> (frame, (link_id, idx)));
		env3 := <vm-jump(|env2)> lbl
	 
	// FVM_ScopeExit/1
	// Move execution to a parent scope without actually returning
	// Can be seen as functioning like a break statement
	eval: (FVM_ScopeExit(FVM_Path(path)), env1) -> env2
	  where
		(frame, FVM_Link(link_id)) := <resolve> (path, FrameRef(<frame-this(|env1)>), env1);
		env2 := <frame-set-current(|env1)> (<cont-this(|env1)>, <frame-get-link(|env1)> (frame, link_id))
		
	// Get a Slot or Link with the given id and frame
	frame-get: (env, frame, FVM_Link(Bind(link_id, idx))) -> FrameRef(<frame-get-link(|env)> (frame, (link_id, idx)))
	frame-get: (env, frame, FVM_Slot(slot_id))            -> <frame-get-slot(|env)> (frame, slot_id)				// Normal slots
	frame-get: (env, frame, FVM_Cont(Bind(name, idx)))    -> <cont-get(|env)> (frame, (name, idx))				// Continuation slots
	
	// Resolve a path
	// returns the frame_id and slot/link of the location pointed to
  	resolve: ([slot], FrameRef(frame), env) -> (frame, slot) 
  	resolve: ([h|t], FrameRef(frame), env)  -> <resolve> (t, <frame-get> (env, frame, h), env)
  	
  	