module arithmetic

imports 
	signatures/framevm-sig
	interpreter/common
	interpreter/external

rules
	// IPush/1
	// Pushes the given interger on the stack
	eval: (IPush(i), env1) -> env2
	  where
	  	env2 := <stack-push(|env1)> IntV(i)
	
	// IAdd/0
	// Takes two integers from the stack, adds them together
	// Pushes the result on the stack
	eval: (IAdd(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop(|env)>;
	  	(env2, IntV(e2)) := <stack-pop(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<addS>(e1, e2))
	  	
	// IEq/0
	// Takes two integers from the stack, checks if they are equal
	// and pushes the result on the stack
  	eval: (IEq(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop(|env)>;
	  	(env2, IntV(e2)) := <stack-pop(|env1)>;
	  	env3 := <stack-push(|env2)> <eval-eq> (e1, e2)
	  	
	// ILt/0
	// Takes two integers from the stack, checks if the second is smaller than the first
	// and pushes the result on the stack
  	eval: (ILt(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop(|env)>;
	  	(env2, IntV(e2)) := <stack-pop(|env1)>;
	  	env3 := <stack-push(|env2)> <eval-lt> (e2, e1)

	// Swap/0
	// Swaps the value on top of the stack with the one in (n+1)th position
	eval: (SwapN(n), env1) -> env4
	  where
	  	(env2, e1) := <stack-pop(|env1)>;
	  	v := <string-to-int> n;
	  	(env3, e2) := <eval-swap(|env2)> (v, e1);
	  	env4 := <stack-push(|env3)>
	  	
	eval-swap(|env1): (1, e1) -> (env3, e2)
	  where
	  	(env2, e2) := <stack-pop(|env1)>;
	  	env3 := <stack-push(|env2)> e1
	  	
	eval-swap(|env1): (n, e1) -> (env4, e2)
	  where
	  	_ := <geq>(n, 2);
	  	(env2, tmp) := <stack-pop(|env1)>;
	  	(env3, e2) := <eval-swap(|env2)> (<dec> n, e1);
	  	env4 := <stack-push(|env3)> tmp
	  	
	// Swap/1
	// Takes two values from the stack
	// Pushes them on the stack in reverse order
	eval: (Swap(), env) -> env4
	  where
	  	(env1, e1) := <stack-pop(|env)>;
	  	(env2, e2) := <stack-pop(|env1)>;
	  	env3 := <stack-push(|env2)> e1;
	  	env4 := <stack-push(|env3)> e2
	
	// Check if the to given values are equal
	// TODO: This should return a boolean when these are implemented
	eval-eq: (e1, e2) -> IntV("1")
	  where
	  	_ := <equal> (e1, e2)
	eval-eq: _ -> IntV("0")	
	
	// Check if the to given values are equal
	// TODO: This should return a boolean when these are implemented
	eval-lt: (e1, e2) -> IntV("1")
	  where
	  	_ := <lt> (e1, e2)
	eval-lt: _ -> IntV("0")	

