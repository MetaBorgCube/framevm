module continuations

imports 
	signatures/framevm-sig
	interpreter/common
	interpreter/external
	interpreter/util
	
rules
	// FVM_ContNew/0
	// Push a continuation on the stack of the current execution point
	eval: (FVM_ContNew(), env1) -> env2
	  where
	  	env2 := <stack-push(|env1)> <cont-this(|env1)>
	  	
	// FVM_ContNewR/1
	// Push a continuation on the stack of the execution frame on the stack after a jump to label
	eval: (FVM_ContNewR(FVM_Label(lbl)), env1) -> env4
	  where
	  	(env2, FrameRef(frame)) := <stack-pop-frame(|env1)>;
	  	(env3, cont) := <vm-cont-new(|env2)> (frame, lbl);
	  	env4 := <stack-push(|env3)> cont
	
	// FVM_ContUnpack/0
	// Get the frame enclosed in a continuation
	eval: (FVM_ContUnpack(), env1) -> <fail>
	
	// FVM_ContGet/0
  	// Get index on top of stack of the current frame
  	eval: (FVM_ContGet(), env1) -> env3
  	  where
  	  	(env2, IntV(idx)) := <stack-pop-int(|env1)>;
  	  	env3 := <stack-push(|env2)> <cont-get(|env2)> (<cont-this(|env2)>, ($[_c[idx]], idx))
  	  	
  	// FVM_Get/1
  	// Push a value on the stack, this value is found by following arg1
  	eval: (FVM_ContGet(cont), env1) -> env2
  	  where
  	  	env2 := <stack-push(|env1)> <cont-get(|env1)> (<cont-this(|env1)>, <cont-resolve> cont)

	// FVM_ContSet/0
	// Store value on top of stack in slot on second position on stack of the current frame
  	eval: (FVM_ContSet(), env1) -> env4
  	  where
  	  	(env2, value) := <stack-pop-any(|env1)>;
  	  	(env3, IntV(idx)) := <stack-pop-int(|env2)>;
  	  	env4 := <cont-set(|env3)> (<cont-this(|env3)>, ($[_c[idx]], idx), value)
  	  	
	// FVM_ContSet/1
	// Store the value on top of the stack at the location found by traversing arg1 
  	eval: (FVM_ContSet(p), env1) -> env3
  	  where
  	  	(env2, value) := <stack-pop-any(|env1)>;
  	  	(cont, slot) := (<cont-this(|env2)>, <cont-resolve> p);
  	  	env3 := <cont-set(|env2)> (cont, slot, value)
  	  	
  	// FVM_ContGetR/0
  	// Get index on top of stack in frame on second position
  	eval: (FVM_ContGetR(), env1) -> env4
  	  where
  	  	(env2, IntV(idx)) := <stack-pop-int(|env1)>;
  	  	(env3, cont) := <stack-pop-cont(|env2)>;
  	  	env4 := <stack-push(|env3)> <cont-get(|env3)> (cont, ($[_c[idx]], idx))
  	
  	// FVM_ContGetR/1
  	// Push a value on the stack, this value is found by 
  	// following arg1 (starting from the frame on top of the stack)
  	eval: (FVM_ContGetR(p), env1) -> env3
  	  where
  	  	(env2, cont) := <stack-pop-cont(|env1)>;
  	  	env3 := <stack-push(|env2)> <cont-get(|env2)> (cont, <cont-resolve> p)

	// FVM_ContSetR/0
	// Store value on top of stack in slot on second position of frame on third position
  	eval: (FVM_ContSetR(), env1) -> env5
  	  where
  	  	(env2, value) := <stack-pop-any(|env1)>;
  	  	(env3, IntV(idx)) := <stack-pop-int(|env2)>;
  	  	(env4, cont) := <stack-pop-cont(|env3)>;
  	  	env5 := <cont-set(|env4)> (cont, ($[_c[idx]], idx), value)
  	
	// FVM_ContSetr/1
  	// Store the value on top of the stack at 
  	// the location found by traversing arg1 from the frame on second position on the stack
  	eval: (FVM_ContSetR(p), env1) -> env4
  	  where
  	  	(env2, value) := <stack-pop-any(|env1)>;
  	  	(env3, cont) := <stack-pop-cont(|env2)>;
  	  	slot := <cont-resolve> p;
  	  	env4 := <cont-set(|env3)> (cont, slot, value)

	//FVM_ContRGet/0
	eval: (FVM_ContRGet(), env) -> env		//TODO: some check that the |stack| == 1
	
	//FVM_ContRGetN/1
	eval: (FVM_ContRGetN(n), env) -> env	//TODO: some check that the |stack| == n
	
	//FVM_ContTransfer/2
	eval: (FVM_ContTransfer(n, p), env1) -> env3
	  where
	    cont := <cont-get(|env1)> (<cont-this(|env1)>, <cont-resolve> p);
	  	(env2, vals) := <pop-list(|env1)> <string-to-int> n;
	  	env3 := <cont-transfer(|env2)> (cont, vals)
	
	//FVM_ContTransfer/1
	eval: (FVM_ContTransfer(n), env1) -> env4
	  where
	    (env2, cont) := <stack-pop-cont(|env1)>;
	  	(env3, vals) := <pop-list(|env2)> <string-to-int> n;
	  	env4 := <cont-transfer(|env3)> (cont, vals)
	  	
	eval: (FVM_ContCall(lbl), env1) -> env4
	  where
	  	(env2, cont) := <stack-pop-cont(|env1)>;
	  	env3 := <vm-jump(|env2)> lbl;
	  	env4 := <cont-call(|env3)> cont
	  	
	eval: (FVM_ContCall(p, lbl), env1) -> env3
	  where
	  	cont := <cont-get(|env1)> (<cont-this(|env1)>, <cont-resolve> p);
	  	env2 := <vm-jump(|env1)> lbl;
	  	env3 := <cont-call(|env2)> cont
	  	
	
	eval: (FVM_ContReturn(), env1) -> env3
	  where
	  	(env2, cont) := <stack-pop-cont(|env1)>;
	  	env3 := <cont-call(|env2)> cont
	  	
	eval: (FVM_ContReturn(p), env1) -> env2
	  where
	  	cont := <cont-get(|env1)> (<cont-this(|env1)>, <cont-resolve> p);
	  	env2 := <cont-call(|env1)> cont