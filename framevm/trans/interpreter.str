module interpreter

imports signatures/framevm-sig

signature
  sorts V
  constructors
    FrameRef : String -> V
    IntV : Int -> V
    
rules 
	external init-vm(|)			// env
	external start-vm(|)		// env -> env'
	external stop-vm(|)			// env -> string
	external store-routine(|)	// (env, (lbl, [instr])) -> env' 
	external next-instr(|)		// env -> (instr, env')
	
	external stack-push(|)		// (env, val) -> env'
	external stack-pop(|)		// (env) -> (env', val)
	
	external frame-get-slot(|)	// (env, frame_id, slot) -> val
	external frame-get-link(|)	// (env, frame_id, link) -> frame_id
	external frame-set(|)		// (env, (frame_id, slot, val)) -> env'
	external frame-new(|)		// env -> (env', frame_id)
	external frame-this(|)		// env -> frame_id
	external frame-link(|)		// (env, (frame_id, frame_id, lbl)) -> env'
	
	external vm-print(|)		// (env, val) -> env'
	external vm-jump(|)			// (env, lbl) -> env'
	external vm-call(|)			// (env, (frame_id, lbl, lbl)) -> env'
	external vm-return(|)		// (env, value) -> env'

  	eval : Program(blocks) -> out
      where 
    	env1 := <init-vm>;
      	env2 := <foldl(store-block)> (blocks, env1);
      	env3 := <start-vm> env2;
    	env4 := <execute> env3;
    	out  := <stop-vm> env4
    	
  	store-block: (Routine(Label(lbl), Seq(body)), env) -> <store-routine> (env, (lbl, body))
  	store-block: (PseudoCode(_), env) -> env
    
  	execute = 
    	repeat(next-instr; debug(!"execute: "); eval) // this should not be defined recursively!
    
rules // arithmetic 
	eval: (IConst(i), env) -> <stack-push> (env, IntV(i))
	
	eval: (IAdd(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop> env;
	  	(env2, IntV(e2)) := <stack-pop> env1;
	  	env3 := <stack-push> (env2, IntV(<addS>(e1, e2)))


rules // control 
	eval: (Call(Label(routine), Label(returnAddr)), env1) -> <vm-call> (env2, (frame_id, routine, returnAddr))
	  where
	  	(env2, FrameRef(frame_id)) := <stack-pop> env1
	  	
	eval: (Return(), env) -> <vm-return> <stack-pop> env
	
	eval: (Jump(Label(lbl)), env) -> <vm-jump> (env, lbl)
	
	eval: (JumpZ(Label(then), Label(else)), env1) -> <vm-jump> (env2, trgt)
	  where
	  	(env2, IntV(val)) := <stack-pop> env1;
	  	trgt := <jump-eval> (val, then, else)

	jump-eval: ("1", _, else) -> else
	jump-eval: ("0", then, _) -> then

rules // frame instructions

	eval: (Dup(), env) -> env4
	  where
	  	(env2, val) := <stack-pop> env;
	  	env3 := <stack-push> (env2, val);
	  	env4 := <stack-push> (env3, val)
	  	
  	eval: (New(), env) -> <stack-push> (env1, FrameRef(frame_id))
  	  where
  	  	(env1, frame_id) := <frame-new> env
  	
  	eval: (Get(Path(p)), env) -> <stack-push> (env, <frame-get> (env, frame_id, slot))
  	  where
  	  	(frame_id, slot) := <resolve> (p, FrameRef(<frame-this>), env)

  	eval: (Set(Path(p)), env1) -> <frame-set> (env2, (frame, slot, value))
  	  where
  	  	(frame, Slot(slot)) := <resolve> (p, FrameRef(<frame-this>), env1);
  	  	(env2, value) := <stack-pop> env1
  	  	
  	eval: (GetR(Path(p)), env1) -> <stack-push> (env2, <frame-get> (env2, frame_id, slot))
  	  where
  	  	(env2, frame) := <stack-pop> env1;
  	  	(frame_id, slot):= <resolve> (p, frame, env2)

  	eval: (SetR(Path(p)), env1) -> <frame-set> (env3, (frame, slot, value))
  	  where
  	  	(env2, value) := <stack-pop> env1;
  	  	(env3, frame_init) := <stack-pop> env2;
  	  	(frame, Slot(slot)) := <resolve> (p, frame_init, env1)

	eval: (LinkR(lbl), env1) -> <frame-link> (env2, (frame_from_id, frame_to_id, lbl))
	  where
	  	frame_to_id := <frame-this> env1;
	  	(env2, FrameRef(frame_from_id)) := <stack-pop> env1
	  	
	eval: (Link(Path(path), lbl), env1) -> <frame-link> (env2, (frame_from_id, frame_to_id, lbl))
	  where
	  	frame_to_id := <frame-this> env1;
	  	(frame_id, aaa) := <resolve> (path, FrameRef(<frame-this>), env1);
	  	_ := <debug> aaa;
	  	(env2, FrameRef(frame_from_id)) := <stack-pop> env1
	
	
	frame-get: (env, frame_id, Link(link_id)) -> <frame-get> (env, frame_id, link_id)
	frame-get: (env, frame_id, Slot(slot_id)) -> <frame-get-slot> (env, frame_id, slot_id)
	frame-get: (env, frame_id, "r") -> <frame-get-slot> (env, frame_id, "r")
	frame-get: (env, frame_id, link_id) -> <frame-get-link> (env, frame_id, link_id)
	
  	resolve: ([slot_id], FrameRef(frame_id), env) -> (frame_id, slot_id) 
  	resolve: ([h|t], FrameRef(frame_id), env) -> <resolve> (t, <frame-get> (env, frame_id, h), env)
  	
rules	// Other
	eval: (Print(), env1) -> env3
	  where
	  	(env2, out) := <stack-pop> env1;
	  	env3 := <vm-print> ( env2, <debug> <val-to-string> out)

	eval: (instr, env) -> env
	  where
	  	_ := <debug> ("Instruction not implemented", instr);
	  	_ := <fail>
	
	
rules
	val-to-string: IntV(v) -> v
	val-to-string: FrameRef(v) -> v
	
	
	