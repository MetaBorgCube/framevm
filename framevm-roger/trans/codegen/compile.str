module compile

imports
	codegen/count-use
	signatures/expressions-sig
	signatures/framevm-roger-sig
	desugar
	
imports
	signatures/framevm-stacy-sig
    
rules
  	compile-rgr: RGR_Program(FVM_InitSize(s), l, blocks) -> RGR_Program(FVM_InitSize(s), l, <map(compile-rgr)> blocks)
// 	compile-rgr: RGR_PseudoCode(body) -> FVM_PseudoCode(body)
  	compile-rgr: RGR_Block(FVM_Label(lbl), body) -> STC_Block(FVM_Label(lbl), <compile-rgr> body)
  	compile-rgr: Seq(body, _) -> <fix-compiled-seq> Seq(body')
  	  where
  	  	Seq(body2, vars) := <count-use> Seq(body);
  	  	(body', _, stack) := <foldl(compile-instr)> (body2, ([], <map(transform-vars)> vars, 0))
  
    compile-rgr: f@Seq(body) -> <fix-compiled-seq> Seq(body')
  	  where
  	  	Seq(body2, vars) := <count-use> f;
  	  	(body', _, stack) := <foldl(compile-instr)> (body2, ([], <map(transform-vars)> vars, 0))
  	
  	transform-vars: (name, use, _, _) -> (name, -1, use)
  	
	fix-compiled-seq: Seq([body]) -> STC_SeqJump([], body)
    fix-compiled-seq: Seq(body) -> STC_SeqJump(body', last)
      where
      	(body', last) := <split-init-last> body
  	
  	
  	init-name: (_, []) -> <fail>
  	init-name: ((name, loc), [(name, _, u) | t]) -> [(name, loc, u)]
  	init-name: (name, [h|t]) -> [h | <init-name> (name, t)]
  	
  	lookup-name: (_, []) -> <fail>
  	lookup-name: (name, [(name, loc, u) | _]) -> (loc, u)
  	lookup-name: (name, [h|t]) -> <lookup-name> (name, t)
  	
  	use-name: (_, []) -> <fail>
  	use-name: (name, [(name, loc, u) | t]) -> ([(name, loc, nu) | t], nu) where nu := <dec> u
  	use-name: (name, [h|t]) -> ([h | tail], nu) with (tail, nu) := <use-name> (name, t)
  	
  	compile-instr: (Nop(), (body, vars, stack)) -> (body, vars, stack)
  	compile-instr: (Control(control), env) -> <compile-control> (control, env)
  	compile-instr: (Control(control, refs), env1) -> env3
  	  with
		(cpm_refs, env2) := <foldr(!env1, compile-exp)> refs;
		(control', env3) := <compile-control> (control, env2)
  			
  			
  	compile-instr: (RGR_PathAlias(name, exp), v) -> <fail><debug> "A path-alias should no longer exist at this point"
  	
  	compile-instr: (Terminal(exp, pure), (body, vars, stack))    -> <compile-exp> (exp, (body, vars, stack))
  	compile-instr: (Assign(ids, exp, pure), (body, vars, stack)) -> <compile-exp> (exp, (body, <init-name>((ids, stack), vars), <inc> stack))
	

  	compile-exp: (RGR_Ref(name), (body, vars, stack)) -> (<append> (body, STC_DupN(<int-to-string> <dec> <subt> (stack, loc))), vars', <inc> stack)
  	  where
  	  	(loc, u) := <lookup-name> (name, vars);
  	  	_ := <gt> (u, 1);
  	  	(vars', _) := <use-name> (name, vars)
  	  	
  	compile-exp: (RGR_Ref(name), (body, vars, stack)) -> (body, vars', <inc> stack)
  	  where
  	  	(loc, u) := <lookup-name> (name, vars);
  	  	_ := <eq> (1, u);
  	  	_ := <eq> (1, <dec> <subt> (stack, loc));
  	  	(vars', _) := <use-name> (name, vars)
  	  	
  	 // TODO: Ref case where we need to swap
  	  	
	append: ([], elems) -> elems where <is-list> elems
	append: ([], elem)  -> [elem]
	append: (list, elems) -> <concat> [list, elems] where <is-list> elems
	append: (list, elem)  -> <concat> [list, [elem]]

  	compile-exp: (RGR_IPush(n), (body, vars, stack)) -> (<append> (body, STC_IPush(n)), vars, <inc> stack)
	compile-exp: (RGR_INeg(exp), env) -> (<append> (body, STC_INeg()), vars, <dec> stack)
	  with
	  	(body, vars, stack) := <compile-exp> (exp, env)
	
	compile-exp: (RGR_IAdd(exp1, exp2), env1) -> (<append> (body, STC_IAdd()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)  	
	  	
	compile-exp: (RGR_IMul(exp1, exp2), env1) -> (<append> (body, STC_IMul()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_ISub(exp1, exp2), env1) -> (<append> (body, STC_ISub()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_IDiv(exp1, exp2), env1) -> (<append> (body, STC_IDiv()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_IMod(exp1, exp2), env1) -> (<append> (body, STC_IMod()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_IEq(exp1, exp2), env1) -> (<append> (body, STC_IEq()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_ILt(exp1, exp2), env1) -> (<append> (body, STC_ILt()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_IGt(exp1, exp2), env1) -> (<append> (body, STC_IGt()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_IOr(exp1, exp2), env1) -> (<append> (body, STC_IOr()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_IXor(exp1, exp2), env1) -> (<append> (body, STC_IXor()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (RGR_IAnd(exp1, exp2), env1) -> (<append> (body, STC_IAnd()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	  	

//	count-use-exp: (RGR_IsInt(exp), v)   -> <count-use-exp> (exp, v)
//	count-use-exp: (RGR_IsCont(exp),v)   -> <count-use-exp> (exp, v)
//	count-use-exp: (RGR_IsFrame(exp), v) -> <count-use-exp> (exp, v)
//	
//	count-use-exp: (IntLEZ(_), v) -> v
//	count-use-exp: (RGR_New(exp), v) -> <count-use-exp> (exp, v)
//	
//	count-use-exp: (RGR_New(), v) -> v
//	
//	count-use-exp: (RGR_Link(exp1, exp2,_), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	
// 
//	count-use-exp: (RGR_Set(exp1, exp2), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	count-use-exp: (RGR_SetR(exp1, exp2, exp3), v) -> <count-use-exp> (exp3, <count-use-exp> (exp2, (<count-use-exp> (exp1, v))))
//	count-use-exp: (RGR_Get(exp), v) -> <count-use-exp> (exp, v)
//	count-use-exp: (RGR_GetR(exp1, exp2), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	
//	count-use-exp: (RGR_ContThis(), v) -> v
//	count-use-exp: (RGR_ContNew(_, _), v) -> v
//	count-use-exp: (RGR_ContTransfer(exp, _), v) -> <count-use-exp> (exp, v)
//	
//	count-use-exp: (RGR_ContSet(_, exp), v) -> <count-use-exp> (exp, v)
//	count-use-exp: (RGR_ContSetR(exp1, _, exp2), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	count-use-exp: (RGR_ContGet(exp), v) -> <count-use-exp> (exp, v)
//	count-use-exp: (RGR_ContGetR(exp1, exp2), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//
//	count-use-exp: (RGR_ScopeExit(_), v) -> v
//	count-use-exp: (RGR_ScopeNew(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-exp: (RGR_ScopeSetCurrent(exp), v) -> <count-use-exp> (exp, v)
	compile-exp: (RGR_Print(exp), env) -> (<append> (body, STC_Print()), vars, <dec> stack)
	  with
	  	(body, vars, stack) := <compile-exp> (exp, env)
	count-use-exp: (RGR_Debug(), (body, vars, stack)) -> (<append> (body, STC_Debug()), vars, stack)
//	
//	count-use-exp: (RGR_Path(_), v) -> v
//  	
//  
//  	
	compile-control: (RGR_Return([exp]), env) -> (<append> (body, STC_Return()), vars, <dec> stack)
	  with
	  	(body, vars, stack) := <compile-exp> (exp, env)
	  	
//	compile-control: (RGR_Return(exps), v) -> <foldl(count-use-exp)> (exps, v)
//	count-use-control: (RGR_Yield(exps, _),<foldl(count-use-exp)> (exps, v) v) -> <foldl(count-use-exp)> (exps, v)
//	count-use-control: (RGR_JumpZ(exp, _, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (RGR_Jump(_), v) -> v
//	count-use-control: (RGR_Call(exp, _, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (RGR_Call(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (RGR_TailCall(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (RGR_TailCall(exp), v) -> <count-use-exp> (exp, v)
//	count-use-control: (RGR_ContCall(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (RGR_ContReturn(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (RGR_ContReturn(exp), v) -> <count-use-exp> (exp, v)
//	
//	count-use-control: (RGR_Try(exp1, _, exp2, _, _), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	count-use-control: (RGR_Try(exp1, exp2, _), v) ->  <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	count-use-control: (RGR_Throw(exp), v) -> <count-use-exp> (exp, v)
//	
//	count-use-control: (RGR_ScopeExit(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (RGR_ScopeNew(exp, _, _), v) -> <count-use-exp> (exp, v)
//
