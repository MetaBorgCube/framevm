module interpreter_jump

language framevm

fixture [[MAIN:
	[[...]]

LBL1:
	stack := 1
	ipush 1
	print
	ipush 0
	return
	
LBL2:
	stack := 1
	ipush 2
	print
	ipush 0
	return
]]

test unconditional jump 1 [[
	jump LBL1
]] transform "Run -> Run" to "IntV(1)"

test unconditional jump 2 [[
	jump LBL2
]] transform "Run -> Run" to "IntV(2)"


test conditional jump 1 [[
	ipush 0
	jumpz LBL1 LBL2
]] transform "Run -> Run" to "IntV(1)"

test conditional jump 2 [[
	ipush 1
	jumpz LBL1 LBL2
]] transform "Run -> Run" to "IntV(2)"


test call/2 1 [[
	new
	dup
	link [] P
	call LBL1 LBL2
]] transform "Run -> Run" to "IntV(1)
IntV(2)"

test call/2 2 [[
	new
	dup
	link [] P
	call LBL2 LBL1
]] transform "Run -> Run" to "IntV(2)
IntV(1)"


test call/1 1 [[
	new
	cnew LBL1 2
	call LBL2
]] transform "Run -> Run" to "IntV(1)
IntV(2)"

test call/1 2 [[
	new
	cnew LBL2 2
	call LBL1
]] transform "Run -> Run" to "IntV(2)
IntV(1)"

test return [[
	new
	cnew LBL2 2
	call LBL3
LBL3:
	rget
	print
	ipush 0
	return
]] transform "Run -> Run" to "IntV(2)
IntV(0)"

test newscope 1 [[
	new
	newscope P LBL1
]] transform "Run -> Run" to "IntV(1)"

test newscope 2 [[
	new
	newscope P LBL2
]] transform "Run -> Run" to "IntV(2)"

test newscope 1 [[
	new
	newscope P LBL3
	
LBL3:
	exitscope [P] LBL4
	
LBL4:
	get []
	print
	jump LBL1
]] transform "Run -> Run" to "Frame(frame_0)
IntV(1)"

test exitscope 2 [[
	new
	dup
	newscope P
	new
	dup
	swap 2
	linkr P
	mkcurrent 
	jump LBL3
	
LBL3:
	exitscope [P, P] LBL4
	
LBL4:
	get []
	print
	jump LBL2
]] transform "Run -> Run" to "Frame(frame_0)
IntV(2)"

test newscope [[
	new
	dup
	newscope P
	new
	dup
	swap 2
	linkr P
	mkcurrent 
	jump LBL4
	
LBL3:
	exitscope [P, P] LBL4
	
LBL4:
	get []
	print
	ipush 0
	return
]] transform "Run -> Run" to "Frame(frame_2)"

