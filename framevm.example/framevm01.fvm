{
  var x := 10  // path of x = [0]
  var y := 11  // path of y = [1]
  print(x)
  print(y)
}

TEST1:
//	new 		// Is this needed?
//	mkcurrent	// Same here
	iconst 10
	set [0] 
	iconst 11
	set [1]
	get [0]
	print
	get [1]
	print

{ 
  rec Point = {
  	x : Int // [0] 
  	y : Int // [1]
  }
  var p : Point // [0]
  p.x := 10  // [0]
  p.y := p.x + 1
  print(p.y)	// print 11
}

TEST2:
	new
	set [0]
	iconst 10
	set [0, 0]   // set p.x
	iconst 1
	get [0, 0]   // p.x
	addi
	set [0, 1]   // set p.y
	get [0, 1]
	print


{
	x := 1
	y := 2
	if x:
		x := y
	else:
		x := 10
	print(x)
}
TEST3:
	iconst 1
	set [0]
	iconst 2
	set [1]
	get [0]
	jumpz THEN ELSE

THEN:
	get [1]
	set [0]
	jump CONT
  
ELSE:
	iconst 10
	set [0]
	jump CONT
 
CONT:
	get [0]
	print
	
{  
	func (i, j) = { 
  		return i + j
	}
	x := 10
	y := func(1, 3)
	print(y)
}

ADD:
  	get [0] // i
  	get [1] // j
  	addi
  	return

TEST4:
	iconst 10		//
	set [0] 		// value of x in current frame
	new 			// create new call frame
	dup 			// duplicate ref to call frame
	iconst 1 		// 
	setr [0] 		// j := 2 // assign to formal parameter j in call frame
	dup
	iconst 3 		// 
	setr [1] 		// j := 2 // assign to formal parameter j in call frame
	call ADD CONT2	// create operand stack with frame ref on top of stack and run INC
					// Returns to CONT
CONT2:
	get [r]			// Get return value
	print
