{
	gen func ():int = {
		yield 1
		throw 2
		yield 3
	}
	
	for i in func():
		print(i)	
		
	print(1)
	// uncought exception IntV(2)
}

MAIN:
	new						// For frame
	dup						//
	link [] P				//
							//
	newscope FOR_INIT		// Enter for loop
	
MAIN_END:
	ipush 1
	print
	ipush 0					//
	return					// exitcode 0
	
FOR_INIT:
	new	1					// Try frame
	dup						//
	link [] P				//
							//
	new						// Catch frame
	dup						//
	link [] P				//
							//
	try FOR_START FOR_END MAIN_END	// Create try-catch blocks and run
	
FOR_START:
	new						// Call frame for generator
	dup						//
	link [] P				// Link it
							//
	call FUNC_1 FOR_BODY	// Start the generator with an initial call
	
FOR_BODY:
	rget					// Get generator value
	dup						//
	getr [0]				// Get result value
	set [0]					// Store in i
							//
	get [0]					//
	print					// print i
							//
	getr [1]				// Get continuation
	call FOR_BODY			// Call it

FOR_END:
	rget						//
	dup							//
	ipush -1					//
	eqi							// Check if exception value == -1 (generator empty)
	jumpz FOR_THROW FOR_EXIT	// Else propagate the exception upwards
	
FOR_THROW:
	throw					// Propagate the exception
	
FOR_EXIT:
	pop						// Pop exception dup
	exitscope [P] MAIN_END	// just go back to the main
	
FUNC_1:
	new	2					// Return object frame
	dup						//
	ipush 1					//
	setr [0]				// Result = 1
							//
	dup						//
	cget []					// Create continuation
	setr [1]				// Store in return object
							//
	transfer 1 [c]			// Yield
	cget [c]				//
	ccall FUNC_2			//
	
FUNC_2:
	ipush 2					//
	throw					// Throw exception
	
FUNC_3:
	new	2					// Return object frame
	dup						//
	ipush 3					//
	setr [0]				// Result = 1
							//
	dup						//
	cget []					// Create continuation
	setr [1]				// Store in return object
							//
	transfer 1 [c]			// Yield
	cget [c]				//
	ccall FUNC_END			//
	
FUNC_END:
	ipush -1				// No more elements
	throw					// Therefore throw some exception (-1 in this case)
	
