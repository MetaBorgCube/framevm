{
  var x := 10  // path of x = [0]
  var y := 11  // path of y = [1]
}

new 
mkcurrent 
pushi 10
set [0] 
pushi 11
set [1]

{ 
  record Point = {x : Int [0], y : Int [1]} 
  var p : Point [0]
  p.x := 10  // 
  p.y := p.x + 1
}

new
set [0]
pushi 10
set [0, 0]   // set p.x
pushi 1
get [0, 0]   // p.x
add
set [0, 1]   // set p.y

{

if x then x := y else x := 10;
print(x)

}

get [0]
jumpz Then Else

Then:
  get [1]
  set [0]
  return Cont
  
Else:
  pushi 10
  set [0]
  jump Cont
 
Cont:
  get [0]
  print
  
  
inc(i, j) { 
  return i + j
}
x := 10
y := inc(x, 2)
print(y)

Inc :
  // 
  get [0] // i
  get [1] // j
  add
  return // takes return address from opstack 
         // copies top of stack to caller stack 
  
new // create new call frame
dup // duplicate it
pushi 10
set [0] // value of x in current frame
setr [0] // i := x // assign to formal parameter i in call frame
dup // duplicate ref to call frame
pushi 2 // 
setr [1] // j := 2 // assign to formal parameter j in call frame
opst Cont // create operand stack with frame ref on top of stack
jump Inc  // takes operand stack as param and return address

Cont:
  get [1] // y
  print





  