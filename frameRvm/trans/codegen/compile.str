module compile

imports
	codegen/count-use
	signatures/frameRvm-sig
	signatures/expressions-sig
	desugar
	
imports
	signatures/framevm-sig
    
rules
  	compile-fvmr: FVMR_Program(FVMR_InitSize(s), l, blocks) -> FVM_Program(FVM_InitSize(s), l, <map(compile-fvmr)> blocks)
 	compile-fvmr: FVMR_PseudoCode(body) -> FVM_PseudoCode(body)
  	compile-fvmr: FVMR_Block(FVMR_Label(lbl), body) -> FVM_Block(FVM_Label(lbl), <compile-fvmr> body)
  	compile-fvmr: Seq(body, _) -> <fix-compiled-seq> Seq(body')
  	  where
  	  	Seq(body2, vars) := <count-use> Seq(body);
  	  	(body', _, stack) := <foldl(compile-instr)> (body2, ([], <map(transform-vars)> vars, 0))
  
    compile-fvmr: f@Seq(body) -> <fix-compiled-seq> Seq(body')
  	  where
  	  	Seq(body2, vars) := <count-use> f;
  	  	(body', _, stack) := <foldl(compile-instr)> (body2, ([], <map(transform-vars)> vars, 0))
  	
  	transform-vars: (name, use, _, _) -> (name, -1, use)
  	
	fix-compiled-seq: Seq([body]) -> FVM_SeqJump([], body)
    fix-compiled-seq: Seq(body) -> FVM_SeqJump(body', last)
      where
      	(body', last) := <split-init-last> body
  	
  	
  	init-name: (_, []) -> <fail>
  	init-name: ((name, loc), [(name, _, u) | t]) -> [(name, loc, u)]
  	init-name: (name, [h|t]) -> [h | <init-name> (name, t)]
  	
  	lookup-name: (_, []) -> <fail>
  	lookup-name: (name, [(name, loc, u) | _]) -> (loc, u)
  	lookup-name: (name, [h|t]) -> <lookup-name> (name, t)
  	
  	use-name: (_, []) -> <fail>
  	use-name: (name, [(name, loc, u) | t]) -> ([(name, loc, nu) | t], nu) where nu := <dec> u
  	use-name: (name, [h|t]) -> ([h | tail], nu) with (tail, nu) := <use-name> (name, t)
  	
  	compile-instr: (Nop(), (body, vars, stack)) -> (body, vars, stack)
  	compile-instr: (Control(control), env) -> <compile-control> (control, env)
  	compile-instr: (Control(control, refs), env1) -> env3
  	  with
		(cpm_refs, env2) := <foldr(!env1, compile-exp)> refs;
		(control', env3) := <compile-control> (control, env2)
  			
  			
  	compile-instr: (FVMR_PathAlias(name, exp), v) -> <fail><debug> "A path-alias should no longer exist at this point"
  	
  	compile-instr: (Terminal(exp, pure), (body, vars, stack))    -> <compile-exp> (exp, (body, vars, stack))
  	compile-instr: (Assign(ids, exp, pure), (body, vars, stack)) -> <compile-exp> (exp, (body, <init-name>((ids, stack), vars), <inc> stack))
	

  	compile-exp: (FVMR_Ref(name), (body, vars, stack)) -> (<append> (body, FVM_DupN(<int-to-string> <dec> <subt> (stack, loc))), vars', <inc> stack)
  	  where
  	  	(loc, u) := <lookup-name> (name, vars);
  	  	_ := <gt> (u, 1);
  	  	(vars', _) := <use-name> (name, vars)
  	  	
  	compile-exp: (FVMR_Ref(name), (body, vars, stack)) -> (body, vars', <inc> stack)
  	  where
  	  	(loc, u) := <lookup-name> (name, vars);
  	  	_ := <eq> (1, u);
  	  	_ := <eq> (1, <dec> <subt> (stack, loc));
  	  	(vars', _) := <use-name> (name, vars)
  	  	
  	 // TODO: Ref case where we need to swap
  	  	
	append: ([], elems) -> elems where <is-list> elems
	append: ([], elem)  -> [elem]
	append: (list, elems) -> <concat> [list, elems] where <is-list> elems
	append: (list, elem)  -> <concat> [list, [elem]]

  	compile-exp: (FVMR_IPush(n), (body, vars, stack)) -> (<append> (body, FVM_IPush(n)), vars, <inc> stack)
	compile-exp: (FVMR_INeg(exp), env) -> (<append> (body, FVM_INeg()), vars, <dec> stack)
	  with
	  	(body, vars, stack) := <compile-exp> (exp, env)
	
	compile-exp: (FVMR_IAdd(exp1, exp2), env1) -> (<append> (body, FVM_IAdd()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)  	
	  	
	compile-exp: (FVMR_IMul(exp1, exp2), env1) -> (<append> (body, FVM_IMul()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_ISub(exp1, exp2), env1) -> (<append> (body, FVM_ISub()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_IDiv(exp1, exp2), env1) -> (<append> (body, FVM_IDiv()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_IMod(exp1, exp2), env1) -> (<append> (body, FVM_IMod()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_IEq(exp1, exp2), env1) -> (<append> (body, FVM_IEq()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_ILt(exp1, exp2), env1) -> (<append> (body, FVM_ILt()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_IGt(exp1, exp2), env1) -> (<append> (body, FVM_IGt()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_IOr(exp1, exp2), env1) -> (<append> (body, FVM_IOr()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_IXor(exp1, exp2), env1) -> (<append> (body, FVM_IXor()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	
	compile-exp: (FVMR_IAnd(exp1, exp2), env1) -> (<append> (body, FVM_IAnd()), vars, <dec><dec> stack)
	  with
	  	env2 := <compile-exp> (exp1, env1); 
	  	(body, vars, stack) := <compile-exp> (exp2, env2)
	  	

//	count-use-exp: (FVMR_IsInt(exp), v)   -> <count-use-exp> (exp, v)
//	count-use-exp: (FVMR_IsCont(exp),v)   -> <count-use-exp> (exp, v)
//	count-use-exp: (FVMR_IsFrame(exp), v) -> <count-use-exp> (exp, v)
//	
//	count-use-exp: (IntLEZ(_), v) -> v
//	count-use-exp: (FVMR_New(exp), v) -> <count-use-exp> (exp, v)
//	
//	count-use-exp: (FVMR_New(), v) -> v
//	
//	count-use-exp: (FVMR_Link(exp1, exp2,_), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	
// 
//	count-use-exp: (FVMR_Set(exp1, exp2), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	count-use-exp: (FVMR_SetR(exp1, exp2, exp3), v) -> <count-use-exp> (exp3, <count-use-exp> (exp2, (<count-use-exp> (exp1, v))))
//	count-use-exp: (FVMR_Get(exp), v) -> <count-use-exp> (exp, v)
//	count-use-exp: (FVMR_GetR(exp1, exp2), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	
//	count-use-exp: (FVMR_ContThis(), v) -> v
//	count-use-exp: (FVMR_ContNew(_, _), v) -> v
//	count-use-exp: (FVMR_ContTransfer(exp, _), v) -> <count-use-exp> (exp, v)
//	
//	count-use-exp: (FVMR_ContSet(_, exp), v) -> <count-use-exp> (exp, v)
//	count-use-exp: (FVMR_ContSetR(exp1, _, exp2), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	count-use-exp: (FVMR_ContGet(exp), v) -> <count-use-exp> (exp, v)
//	count-use-exp: (FVMR_ContGetR(exp1, exp2), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//
//	count-use-exp: (FVMR_ScopeExit(_), v) -> v
//	count-use-exp: (FVMR_ScopeNew(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-exp: (FVMR_ScopeSetCurrent(exp), v) -> <count-use-exp> (exp, v)
	compile-exp: (FVMR_Print(exp), env) -> (<append> (body, FVM_Print()), vars, <dec> stack)
	  with
	  	(body, vars, stack) := <compile-exp> (exp, env)
	count-use-exp: (FVMR_Debug(), (body, vars, stack)) -> (<append> (body, FVM_Debug()), vars, stack)
//	
//	count-use-exp: (FVMR_Path(_), v) -> v
//  	
//  
//  	
	compile-control: (FVMR_Return([exp]), env) -> (<append> (body, FVM_Return()), vars, <dec> stack)
	  with
	  	(body, vars, stack) := <compile-exp> (exp, env)
	  	
//	compile-control: (FVMR_Return(exps), v) -> <foldl(count-use-exp)> (exps, v)
//	count-use-control: (FVMR_Yield(exps, _),<foldl(count-use-exp)> (exps, v) v) -> <foldl(count-use-exp)> (exps, v)
//	count-use-control: (FVMR_JumpZ(exp, _, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (FVMR_Jump(_), v) -> v
//	count-use-control: (FVMR_Call(exp, _, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (FVMR_Call(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (FVMR_TailCall(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (FVMR_TailCall(exp), v) -> <count-use-exp> (exp, v)
//	count-use-control: (FVMR_ContCall(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (FVMR_ContReturn(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (FVMR_ContReturn(exp), v) -> <count-use-exp> (exp, v)
//	
//	count-use-control: (FVMR_Try(exp1, _, exp2, _, _), v) -> <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	count-use-control: (FVMR_Try(exp1, exp2, _), v) ->  <count-use-exp> (exp2, (<count-use-exp> (exp1, v)))
//	count-use-control: (FVMR_Throw(exp), v) -> <count-use-exp> (exp, v)
//	
//	count-use-control: (FVMR_ScopeExit(exp, _), v) -> <count-use-exp> (exp, v)
//	count-use-control: (FVMR_ScopeNew(exp, _, _), v) -> <count-use-exp> (exp, v)
//
