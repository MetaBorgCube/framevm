module framevm-stacy

imports fvm-common fvm-pseudo

context-free start-symbols Program

sorts Program context-free syntax
  Program.STC_Program = <<imports:Import*>
<InitSize> 
<alias:Alias*>

<body:Block*>
>    { layout (align-list body && align-list alias && align-list imports) }
  
  Program.STC_ProgramNoInit = <<imports:Import*>
<alias:Alias*>

<body:Block*>>    { layout (align-list body && align-list alias && align-list imports) }
  
sorts Block context-free syntax

  Block.STC_Block = <
<lbl:BlockLabel>: 
    <body:Body>

> { layout (indent lbl body) }
  
  Block.STC_PseudoCode = <{ 
      <body:PsdBody>
}

> { layout (indent "{" body && align "{" "}") }
  
  Body.STC_SeqJump = <<instr:Instr*> 
<jump:ControlInstr>
> { layout (align-list instr && align instr jump) }

  Body.STC_RetSeqJump = <<ret:OnReturnInstr>
<instr:Instr*> 
<jump:ControlInstr>
> { layout (align-list instr && align instr jump && align ret instr) }
  
sorts Instr context-free syntax
  Instr.STC_Print       = <print>                 // Prints value on the stack
  Instr.STC_PrintChar   = <printc>                // Prints character on the stack
  Instr.STC_Debug       = <debug>                 // Prints the state of the vm
  Instr.STC_DebugKill   = <debug!>                // Prints the state of the vm and kills execution
  
  
  Instr = IntInstr
  IntInstr.STC_IPush  = <ipush <INT>>             // Push int value to stack
  IntInstr.STC_INeg   = <negi>                    // Negates the integer on top of the stack
  IntInstr.STC_IAdd   = <addi>                    // Consumes two ints from stack and adds them, result is stored on stack
  IntInstr.STC_IMul   = <muli>                    // Consumes two ints from stack and multilpies them, result is stored on stack
  IntInstr.STC_ISub   = <subi>                    // Consumes two ints from stack and subtracts them, result is stored on stack
  IntInstr.STC_IDiv   = <divi>                    // Consumes two ints from stack and divides them, result is stored on stack
  IntInstr.STC_IMod   = <modi>                    // Consumes two ints from stack and mods them, result is stored on stack
  
  IntInstr.STC_IEq       = <eqi>                  // Consumes two ints from stack and equals them, result is stored on stack
  IntInstr.STC_ILt       = <lti>                  // Consumes two ints from stack and performs < on them, result is stored on stack
  IntInstr.STC_IGt    = <gti>                     // Consumes two ints from stack and performs > on them, result is stored on stack
  IntInstr.STC_IOr    = <ori>                     // Consumes two ints from stack and performs binary or on them, result is stored on stack
  IntInstr.STC_IXor   = <xori>                    // Consumes two ints from stack and performs binary xor on them, result is stored on stack
  IntInstr.STC_IAnd   = <andi>                    // Consumes two ints from stack and performs binary and on them, result is stored on stack
  
  
  Instr = StackInstr
  StackInstr.STC_Pop      = <pop>                 // Discards the top value on the stack
  StackInstr.STC_Dup      = <dup>                 // Duplicates the value on the stack
  StackInstr.STC_DupN     = <dup <INTLZ>>         // Duplicates the n-th value on the stack
  StackInstr.STC_Swap     = <swap>                // Swaps two values on the stack
  StackInstr.STC_SwapN    = <swap <INTLZ>>        // Swaps the value on top of the stack with the one in (n+1)th position
  
  
  Instr = TypeInstr
  TypeInstr.STC_IsInt   = <int?>                  // Check if the element on top of the stack is an integer
  TypeInstr.STC_IsCont  = <cont?>                 // Check if the element on top of the stack is a continuation
  TypeInstr.STC_IsFrame = <frame?>                // Check if the element on top of the stack is a data frame
  TypeInstr.STC_IsClos  = <closure?>              // Check if the element on top of the stack is a closure
  
  Instr = FrameInstr
  FrameInstr.STC_New    = <new>                   // Create new frame with 0 slots and push pointer on stack
  FrameInstr.STC_NewR   = <newr>                  // Create new frame number of slots on top of the stackand push pointer on stack
  FrameInstr.STC_New    = <new <INTLEZ>>          // Create new frame with given amount of slots and push pointer on stack
  FrameInstr.STC_FSize  = <size>                  // Get the size of the frame on top of the stack
  
  FrameInstr.STC_Link   = <link <Path> <LinkRef>> // Link frame on stack to given location (Empty path is current frame)
  FrameInstr.STC_LinkR    = <linkr <LinkRef>>     // Link frame on second position on the stack to the frame on top
 
  FrameInstr.STC_Set    = <set>                   // Store value on top of stack in slot on second position of the current frame
  FrameInstr.STC_Set    = <set <Path>>            // Set value on the stack at path location
  FrameInstr.STC_SetR   = <setr>                  // Store value on top of stack in slot on second position of frame on third position
  FrameInstr.STC_SetR   = <setr <Path>>           // Set value on the stack at path location starting in frame on stack
  FrameInstr.STC_Get    = <get>                   // Get index on top of stack of the current frame
  FrameInstr.STC_Get    = <get <Path>>            // Store value at path in the stack
  FrameInstr.STC_GetR   = <getr>                  // Get index on top of stack in frame on second position
  FrameInstr.STC_GetR   = <getr <Path>>           // Store value at path from frame on stack on stack
  
  
  FrameInstr.STC_FrameCopy  = <copy <CopyPolicy>>                // Copy the current frame using the given policy
  FrameInstr.STC_FrameCopyR = <copyr <CopyPolicy>>               // Copy the frame on top of the stack using the given policy
  ContInstr.STC_ContCopy    = <ccopy <CopyPolicy> <CopyPolicy>>  // Copy the current controlframe using the given policy
  ContInstr.STC_ContCopyR   = <ccopyr <CopyPolicy> <CopyPolicy>> // Copy the continuation on top of the stack and propagate using the given policy
  
  
  Instr = ContInstr
  ContInstr.STC_ContThis      = <cget []>                        // Create a new continuation for the current execution point
  ContInstr.STC_ContNew       = <cnew <Label> <INTLEZ>>          // Create a continuation for a frame on the stack at a new execution point
  ContInstr.STC_ContTransfer  = <transfer <INTLEZ> [<ContRef>]>  // Transfer n elements as returned values to the given continuation
  ContInstr.STC_ContTransfer  = <transfer <INTLEZ>>              // Transfer n elements as returned values to the continuation on top of the stack
  
  OnReturnInstr.STC_ContRGetN = <rget <INTLEZ>>                  // Get n returned values onto the stack
  OnReturnInstr.STC_ContRGet  = <rget>                           // Get a return value on the stack
  
  ContInstr.STC_ContSet       = <cset>                           // Store the value on top of the stack in the slot with id on second position
  ContInstr.STC_ContSet       = <cset [<ContRef>]>               // Store the value on top of the stack in the given slot
  ContInstr.STC_ContSetR      = <csetr>                          // Store the value on top of the stack in the slot with id on second position of the continuarioin on third position
  ContInstr.STC_ContSetR      = <csetr [<ContRef>]>              // Store the value on top of the stack in the given slot of the continuarioin on second position
  ContInstr.STC_ContGet       = <cget>                           // Get the continuation from the slot with id on top of the stack
  ContInstr.STC_ContGet       = <cget [<ContRef>]>               // Get the continuation from the given slot
  ContInstr.STC_ContGetR      = <cgetr>                          // Get the continuation from the slot with id on top of the stack from the continuation on second position
  ContInstr.STC_ContGetR      = <cgetr [<ContRef>]>              // Get the continuation from the given slot from the continuation on top of the stack
  
  
  ControlInstr.STC_Return     = <return>                         // Return the calue on top of the stack
  ControlInstr.STC_ReturnN    = <return <INTLEZ>>                // Return n values
  ControlInstr.STC_Yield      = <yield <Label>>                  // Yield a value and the current continuation
  ControlInstr.STC_JumpZ      = <jumpz <Label> <Label>>          // Jump to first label if stack zero, else jump to other label
  ControlInstr.STC_Jump       = <jump <Label>>                   // Unconditional jump to LABEL
  ControlInstr.STC_Call       = <call <Label> <Label>>           // Call block LABEL, using frame on the stack
  ControlInstr.STC_Call       = <call <Label>>                   // Call continuation on the stack with new block
  ControlInstr.STC_TailCall   = <tailcall <Label>>               // Tail-call block LABEL, using frame on the stack
  ControlInstr.STC_TailCall   = <tailcall>                       // Tail-call continuation on the stack
  ControlInstr.STC_ContCall   = <ccall <Label>>                  // Call a continuation
  ControlInstr.STC_ContCall   = <ccall [<ContRef>] <Label>>      // Call the given continuation
  ControlInstr.STC_ContReturn = <cret [<ContRef>]>               // Call the given continuation
  ControlInstr.STC_ContReturn = <cret>                           // Call the continuation on top of the stack
  
  ControlInstr.STC_Try        = <try <Label> <Label> <Label>>    // Execute the frame on second position on the stack and set the first frame as exception handler
  ControlInstr.STC_Try        = <try <Label>>                    // Execute the continuation on second position on the stack and set the first continuation as exception handler
  ControlInstr.STC_Throw      = <throw>                          // Throw the element on top of the stack to the exception handler
  
  FrameInstr.STC_ScopeExit    = <exitscope <Path>>               // Set the frame at path as the current frame
  ControlInstr.STC_ScopeExit  = <exitscope <Path> <Label>>       // Break execution to a higher scope
  FrameInstr.STC_ScopeNew     = <newscope <LinkRef>>             // Set the current frame
  ControlInstr.STC_ScopeNew   = <newscope <LinkRef> <Label>>     // Move execution to another scope and copy over the current continuation
  FrameInstr.STC_ScopeSetCurrent = <mkcurrent>                   // Set the frame on top of the stack as the current dataframe

  Instr = ClosInstr
  ClosInstr.STC_ClosNew      = <newc <CopyPolicy> <Label>>       // Create a new closure form the frame on top of the stack and the given label. Use the given copy policy
  ClosInstr.STC_ClosNew      = <newc <Label>>                    // Create a new closure form the frame on top of the stack and the given label. Uses shallow copy
  ClosInstr.STC_ClosToCont   = <cnew <INTLEZ>>                   // Create a continuation from a closure
  ClosInstr.STC_ClosUnpack   = <unpack>                          // Get the dataframe of the closure on top of the stack
  
  Instr.STC_StringPush       = <spush <STRING>>                  // Push a string on the stack
  Instr.STC_CharPush         = <cpush <CHAR>>                    // Push a character value to stack
  