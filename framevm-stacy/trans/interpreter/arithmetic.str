module arithmetic

imports 
	signatures/framevm-stacy-sig
	interpreter/common
	interpreter/external

rules
	// FVM_IPush/1
	// Pushes the given interger on the stack
	eval: (FVM_IPush(i), env1) -> env2
	  where
	  	env2 := <stack-push(|env1)> IntV(i)
	
	// FVM_INeg/0
	// Takes an integer from the stack and negates it
	// Pushes the result on the stack
	eval: (FVM_INeg(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	env3 := <stack-push(|env1)> IntV(<subtS>("0", e1))
	  	
	// FVM_IAdd/0
	// Takes two integers from the stack, adds them together
	// Pushes the result on the stack
	eval: (FVM_IAdd(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e2)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<addS>(e1, e2))

	// FVM_IMul/0
	// Takes two integers from the stack, multiplies them
	// Pushes the result on the stack
	eval: (FVM_IMul(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e2)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<mulS>(e1, e2))
	  	
	// FVM_ISub/0
	// Takes two integers from the stack, subtracts them
	// Pushes the result on the stack
	eval: (FVM_ISub(), env) -> env3
	  where
	  	(env1, IntV(e2)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e1)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<subtS>(e1, e2))
	  	
	// FVM_IDiv/0
	// Takes two integers from the stack, divides them
	// Pushes the result on the stack
	eval: (FVM_IDiv(), env) -> env3
	  where
	  	(env1, IntV(e2)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e1)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<divS>(e1, e2))
	  	
	// FVM_Imod/0
	// Takes two integers from the stack, divides them
	// Pushes the remainder on the stack	  	
	eval: (FVM_IMod(), env) -> env3
	  where
	  	(env1, IntV(e2)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e1)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<modS>(e1, e2))




	// FVM_IEq/0
	// Takes two integers from the stack, checks if they are equal
	// and pushes the result on the stack
  	eval: (FVM_IEq(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e2)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> <eval-eq> (e1, e2)
	  	
	// FVM_ILt/0
	// Takes two integers from the stack, checks if the second is smaller than the first
	// and pushes the result on the stack
  	eval: (FVM_ILt(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e2)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> <eval-lt> (e2, e1)
	  	
	// FVM_IGt/0
	// Takes two integers from the stack, checks if the second is bigger than the first
	// and pushes the result on the stack
  	eval: (FVM_IGt(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e2)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> <eval-lt> (e1, e2)
	  	
	// FVM_IOr/0
	// Takes two integers from the stack, calculates bitwise or
	// and pushes the result on the stack
  	eval: (FVM_IOr(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e2)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<int-to-string> <iori> (<string-to-int> e1, <string-to-int> e2))

	// FVM_IXor/0
	// Takes two integers from the stack, calculates bitwise or
	// and pushes the result on the stack
  	eval: (FVM_IXor(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e2)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<int-to-string> <xori> (<string-to-int> e1, <string-to-int> e2))
	
	
	// FVM_IAnd/0
	// Takes two integers from the stack, calculates bitwise and
	// and pushes the result on the stack
  	eval: (FVM_IAnd(), env) -> env3
	  where
	  	(env1, IntV(e1)) := <stack-pop-int(|env)>;
	  	(env2, IntV(e2)) := <stack-pop-int(|env1)>;
	  	env3 := <stack-push(|env2)> IntV(<int-to-string> <andi> (<string-to-int> e1, <string-to-int> e2))


	// Check if the to given values are equal
	eval-eq: (e1, e2) -> IntV("1")
	  where
	  	_ := <equal> (e1, e2)
	eval-eq: _ -> IntV("0")	
	
	// Check if the to given values are equal
	eval-lt: (e1, e2) -> IntV("1")
	  where
	  	_ := <lt> (<string-to-int> e1, <string-to-int> e2)
	eval-lt: _ -> IntV("0")	
