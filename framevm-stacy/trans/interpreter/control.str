module control

imports 
    signatures/framevm-stacy-sig
    signatures/fvm-common-sig
    interpreter/external
    interpreter/util
    
    stc-common
    
rules    
    // STC_Call/2
    // Call the block at arg1 using the frame at the top of the stack
    // This function returns to arg2 when finished
    eval: (STC_Call(FVM_BoundLabel(lib, block), FVM_BoundLabel(retlib, retlbl)), env1) -> env7
      where
        (env2, FrameRef(callFrame)) := <stack-pop-frame(|env1)>;      // get the function frame
        (env3, func) := <vm-cont-new(|env2)> (callFrame, (lib, block), 2);
         
        cont_this := <cont-this(|env3)>;
        env4 := <cont-set-cc(|env2)> (func, cont_this);               // Set the return address
        ex := <ex-get-cx(|env3)> cont_this;
        env5 := <ex-set-cx(|env3)> (func, ex);                        // Copy over exception
        env6 := <vm-jump(|env5)> (retlib, retlbl);
        env7 := <cont-call(|env6)> func                               // call the function
          
    // STC_Call/1
    // Call the continuation at the top of the stack with return address set to block
    eval: (STC_Call(FVM_BoundLabel(lib, block)), env1) -> env6
      where
        (env2, Continuation(func)) := <stack-pop-cont(|env1)>;        // get the function continuation
        cont_this := <cont-this(|env2)>;
        env3 := <cont-set-cc(|env2)> (func, cont_this);               // Set the return address
        ex := <ex-get-cx(|env3)> cont_this;
        env4 := <ex-set-cx(|env3)> (func, ex);                        // Copy over exception
        env5 := <vm-jump(|env4)> (lib, block);
        env6 := <cont-call(|env5)> func                               // call the function
     
    // STC_TailCall/1
    // Call the block at arg1 using the frame at the top of the stack
    // Use tail call optimizations for this call
    eval: (STC_TailCall(FVM_BoundLabel(lib, block)), env1) -> env6
      where
        (env2, FrameRef(callFrame)) := <stack-pop-frame(|env1)>;    // get the function frame
        (env3, func) := <vm-cont-new(|env2)> (callFrame, (lib, block), 2);
          
        cont_this := <cont-this(|env3)>;
        return := <cont-get-cc(|env3)> cont_this;
        env4 := <cont-set-cc(|env2)> (func, return);                // Set the return address
        ex := <ex-get-cx(|env3)> cont_this;
        env5 := <ex-set-cx(|env3)> (func, ex);                      // Copy over exception
        env6 := <cont-call(|env5)> func                             // call the function
          
    // STC_TailCall/0
    // Call the continuation at the top of the stack
    // Use tail call optimizations for this call
    eval: (STC_TailCall(), env1) -> env5
      where
        (env2, Continuation(func)) := <stack-pop-cont(|env1)>;      // get the function continuation
        cont_this := <cont-this(|env2)>;
        return := <cont-get-cc(|env2)> cont_this;
        env3 := <cont-set-cc(|env2)> (func, return);                // Set the return address
        ex := <ex-get-cx(|env3)> cont_this;
        env4 := <ex-set-cx(|env3)> (func, ex);                      // Copy over exception
        env5 := <cont-call(|env4)> func                             // call the function
    
    // STC_ReturnN/1
    // Takes n values from the top of the stack and returns them to the caller
    eval: (STC_ReturnN(n), env1) -> env4
      where
        (env2, vals) := <pop-list(|env1)> <string-to-int> n;
        continuation := <cont-get-cc(|env2)> <cont-this(|env2)>;
        env3 := <cont-transfer(|env2)> (continuation, vals);
        env4 := <cont-call(|env3)> continuation
          
    // STC_Return/0
    // Take a value from top of the stack and return it to the caller
    eval: (STC_Return(), env1) -> env4
      where
        (env2, val) := <stack-pop-any(|env1)>;
        continuation := <cont-get-cc(|env2)> <cont-this(|env2)>;
        env3 := <cont-transfer(|env2)> (continuation, [val]);
        env4 := <cont-call(|env3)> continuation
        
    // STC_Yield/1
    // Return the value on top of the stack and the current continuation to the caller.
    // Sets the next instruction to be at the given label
    eval: (STC_Yield(FVM_BoundLabel(lib, block)), env1) -> env5
      where
        this := <cont-this(|env1)>;
        (env2, val) := <stack-pop-any(|env1)>;
        continuation := <cont-get-cc(|env2)> this;
        env3 := <cont-transfer(|env2)> (continuation, [val, Continuation(this)]);
        env4 := <vm-jump(|env3)> (lib, block);
        env5 := <cont-call(|env4)> continuation
   
    // STC_Jump/1
    // Unconditional jump to a new block at the given label
    eval: (STC_Jump(FVM_BoundLabel(lib, block)), env1) -> env2
      where
        env2 := <vm-jump(|env1)> (lib, block)
    
    // STC_JumpZ/2
    // Conditional jump. 
    // Checks top of the stack, when zero goes to arg1 else to arg2
    eval: (STC_JumpZ(FVM_BoundLabel(thenlib, thenlbl), FVM_BoundLabel(elselib, elselbl)), env1) -> env3
      where
        (env2, IntV(val)) := <stack-pop-int(|env1)>;
        trgt := <jump-eval> (val, (thenlib, thenlbl), (elselib, elselbl));
        env3 := <vm-jump(|env2)> trgt
    
    // STC_ScopeNew/1
    // Move execution to a new scope, for example when entering a for loop
    // Uses the frame on top of the stack as new execution frame
    // Jumps the execution to the given block
    eval: (STC_ScopeNew(FVM_Link(Bind(lbl, idx)), FVM_BoundLabel(lib, block)), env1) -> env5
      where
        frame_this := <frame-this(|env1)>;
        (env2, FrameRef(frame_to)) := <stack-pop-frame(|env1)>;
        env3 := <frame-link(|env2)> (frame_to, frame_this, (lbl, idx));
        env4 := <frame-set-current(|env3)> (<cont-this(|env2)>, frame_to);
        env5 := <vm-jump(|env4)> (lib, block)

    // STC_ScopeNew/0
    // Move execution to a new scope, for example when entering a for loop
    // Uses the frame on top of the stack as new execution frame
    eval: (STC_ScopeNew(FVM_Link(Bind(lbl, idx))), env1) -> env4
      where
        frame_this := <frame-this(|env1)>;
        (env2, FrameRef(frame_to)) := <stack-pop-frame(|env1)>;
        env3 := <frame-link(|env2)> (frame_to, frame_this, (lbl, idx));
        env4 := <frame-set-current(|env3)> (<cont-this(|env3)>, frame_to)
          
    // STC_ScopeSetCurrent/0
    // Set the frame on top of the stack as new execution frame (make sure its properly linked)
    eval: (STC_ScopeSetCurrent(), env1) -> env3
      where
        (env2, FrameRef(frame_to)) := <stack-pop-frame(|env1)>;
        env3 := <frame-set-current(|env2)> (<cont-this(|env2)>, frame_to)
    
    // STC_ScopeGetCurrent/0
    // Get the current data frame
    eval: (STC_ScopeGetCurrent(), env1) -> env2
      where
        env2 := <stack-push(|env1)> FrameRef(<frame-this(|env1)>)
          
    // Resolve which label to pick
    jump-eval: (0, then, _) -> then
    jump-eval: (_, _, else) -> else        // Catch all other than 0
