module frame

imports 
    signatures/framevm-stacy-sig
    signatures/fvm-common-sig
    
    interpreter/external
    interpreter/util
    
    stc-common

rules
    // STC_New/0
    // pushes an empty frame with 0 slots on the stack
    eval: (STC_New(), env1) -> env3
      where
        (env2, frame) := <frame-new(|env1)> 0;
        env3 := <stack-push(|env2)> FrameRef(frame)
            
    // STC_New/1
    // pushes an empty frame with n slots on the stack
    eval: (STC_New(n), env1) -> env3
      where
        (env2, frame_id) := <frame-new(|env1)> <string-to-int> n;
        env3 := <stack-push(|env2)> FrameRef(frame_id)
            
    // STC_NewR/0
    // pushes an empty frame with n slots on the stack
    eval: (STC_NewR(), env1) -> env4
      where
        (env2, IntV(n)) := <stack-pop-int(|env1)>;
        (env3, frame_id) := <frame-new(|env2)> n;
        env4 := <stack-push(|env3)> FrameRef(frame_id)
      
    // STC_Get/0
    // Get index on top of stack of the current frame
    eval: (STC_Get(), env1) -> env3
      where
        (env2, IntV(slot)) := <stack-pop-int(|env1)>;
        env3 := <stack-push(|env2)> <frame-get> (env2, <frame-this(|env2)>, FVM_Slot(<int-to-string> slot))
            
    // STC_Get/1
    // Push a value on the stack, this value is found by following arg1
    eval: (STC_Get(FVM_Self()), env1) -> env2
      where
        env2 := <stack-push(|env1)> FrameRef(<frame-this(|env1)>)

    eval: (STC_Get(FVM_Path(p)), env1) -> env2
      where
        (frame_id, slot) := <resolve> (p, FrameRef(<frame-this(|env1)>), env1);
        env2 := <stack-push(|env1)> <frame-get> (env1, frame_id, slot)

    // STC_Set/0
    // Store value on top of stack in slot on second position on stack of the current frame
    eval: (STC_Set(), env1) -> env4
      where
        (env2, value) := <stack-pop-any(|env1)>;
        (env3, IntV(slot)) := <stack-pop-int(|env2)>;
        env4 := <frame-set(|env3)> (<frame-this(|env3)>, FVM_Slot(<int-to-string> slot), value)
            
    // STC_Set/1
    // Store the value on top of the stack at the location found by traversing arg1 
    eval: (STC_Set(FVM_Path(p)), env1) -> env3
      where
        (frame, slot) := <resolve> (p, FrameRef(<frame-this(|env1)>), env1);
        (env2, value) := <stack-pop-any(|env1)>;
        env3 := <frame-set(|env2)> (frame, slot, value)
           
    // STC_GetR/0
    // Get index on top of stack in frame on second position
    eval: (STC_GetR(), env1) -> env4
      where
        (env2, IntV(slot)) := <stack-pop-int(|env1)>;
        (env3, FrameRef(frame)) := <stack-pop-frame(|env2)>;
        env4 := <stack-push(|env3)> <frame-get> (env3, frame, FVM_Slot(<int-to-string> slot))
      
    // STC_GetR/1
    // Push a value on the stack, this value is found by 
    // following arg1 (starting from the frame on top of the stack)
    eval: (STC_GetR(FVM_Self()), env1) -> env1      // This connamd litterally does nothing
    eval: (STC_GetR(FVM_Path(p)), env1) -> env3
      where
        (env2, frame) := <stack-pop-frame(|env1)>;
        (frame_id, slot):= <resolve> (p, frame, env2);
        env3 := <stack-push(|env2)> <frame-get> (env2, frame_id, slot)

    // STC_SetR/0
    // Store value on top of stack in slot on second position of frame on third position
    eval: (STC_SetR(), env1) -> env5
      where
        (env2, value) := <stack-pop-any(|env1)>;
        (env3, IntV(slot)) := <stack-pop-int(|env2)>;
        (env4, FrameRef(frame)) := <stack-pop-frame(|env3)>;
        env5 := <frame-set(|env4)> (frame, FVM_Slot(<int-to-string> slot), value)
     
    // STC_Setr/1
    // Store the value on top of the stack at 
    // the location found by traversing arg1 from the frame on second position on the stack
    eval: (STC_SetR(FVM_Path(p)), env1) -> env4
      where
        (env2, value) := <stack-pop-any(|env1)>;
        (env3, frame_init) := <stack-pop-frame(|env2)>;
        (frame, slot) := <resolve> (p, frame_init, env1);
        env4 := <frame-set(|env3)> (frame, slot, value)

    // STC_FrameCopy/1
    // Copy the current frame and push the copy on the stack
    eval: (STC_FrameCopy(policy), env1) -> env3
      where
        (env2, copy) := <frame-copy(|env1)> (<frame-this(|env1)>, <policy-to-string> policy);
        env3 := <stack-push(|env2)> FrameRef(copy)
   
    // STC_FrameCopyR/1
    // Copy the frame on top of the stack and push the copy on the stack
    eval: (STC_FrameCopyR(policy), env1) -> env4
      where
        (env2, FrameRef(frame)) := <stack-pop-frame(|env1)>;
        (env3, copy) := <frame-copy(|env2)> (frame, <policy-to-string> policy);
        env4 := <stack-push(|env2)> FrameRef(copy)
      
    // STC_Link/2
    // Link the frame on top of the stack to the frame pointed to by arg1
    // using label arg2
    eval: (STC_Link(FVM_Self(), FVM_Link(Bind(lbl, idx))), env1) -> env3
      where
        frame_to := <frame-this(|env1)>;
        (env2, FrameRef(frame_from)) := <stack-pop-frame(|env1)>;
        env3 := <frame-link(|env2)> (frame_from, frame_to, (lbl, idx))
          
    eval: (STC_Link(FVM_Path(path), FVM_Link(Bind(lbl, idx))), env1) -> env3
      where
        (frame_id, slot_id) := <resolve> (path, FrameRef(<frame-this(|env1)>), env1);
        FrameRef(frame_to) := <frame-get> (env1, frame_id, slot_id);
        (env2, FrameRef(frame_from)) := <stack-pop-frame(|env1)>;
        env3 := <frame-link(|env2)> (frame_from, frame_to, (lbl, idx))
          
    // STC_LinkR/1
    // Link the frame on 2nd position to the frame on top of the stack
    eval: (STC_LinkR(FVM_Link(Bind(lbl, idx))), env1) -> env4
      where
        (env2, FrameRef(frame_to_id)) := <stack-pop-frame(|env1)>;
        (env3, FrameRef(frame_from_id)) := <stack-pop-frame(|env2)>;
        env4 := <frame-link(|env3)> (frame_from_id, frame_to_id, (lbl, idx))
     
    // STC_ScopeExit/2
    // Move execution to a parent scope without actually returning
    // Can be seen as functioning like a break statement
    // Breaks to the scpoe at the provided path and move execution to the given block
    eval: (STC_ScopeExit(FVM_Path(path), FVM_BoundLabel(lib, lbl)), env1) -> env2
      where
        (frame, FVM_Link(Bind(link_id, idx))) := <resolve> (path, FrameRef(<frame-this(|env1)>), env1);
        env2 := <frame-set-current(|env1)> (<cont-this(|env1)>, <frame-get-link(|env1)> (frame, (link_id, idx)));
        env3 := <vm-jump(|env2)> (lib, lbl)
     
    // STC_ScopeExit/1
    // Move execution to a parent scope without actually returning
    // Can be seen as functioning like a break statement
    eval: (STC_ScopeExit(FVM_Path(path)), env1) -> env2
      where
        (frame, FVM_Link(Bind(link_id, idx))) := <resolve> (path, FrameRef(<frame-this(|env1)>), env1);
        env2 := <frame-set-current(|env1)> (<cont-this(|env1)>, <frame-get-link(|env1)> (frame, (link_id, idx)))
        
    // STC_FSize/0
    // Get the size of the frame on top of the stack
    eval: (STC_FSize(), env1) -> env3
      where
        (env2, FrameRef(frame)) := <stack-pop-frame(|env1)>;
        size := <frame-size(|env2)> frame;
        env3 := <stack-push(|env2)> IntV(size)
          
    // Get a Slot or Link with the given id and frame
    frame-get: (env, frame, FVM_Link(Bind(link_id, idx))) -> FrameRef(<frame-get-link(|env)> (frame, (link_id, idx)))
    frame-get: (env, frame, FVM_Slot(slot_id))            -> <frame-get-slot(|env)> (frame, <string-to-int> slot_id)    // Normal slots
    frame-get: (env, frame, FVM_Cont(Bind(name, idx)))    -> <cont-get(|env)> (frame, (name, idx))                        // Continuation slots
    
    // Resolve a path
    // returns the frame_id and slot/link of the location pointed to
    resolve: ([slot], FrameRef(frame), env) -> (frame, slot) 
    resolve: ([h|t], FrameRef(frame), env)  -> <resolve> (t, <frame-get> (env, frame, h), env)
      
      
