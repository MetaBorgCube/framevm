module stack

imports
	signatures/framevm-stacy-sig
	signatures/fvm-common-sig
	stc-common

rules
	// check stack sizes of blocks
	stack-calc: STC_Program(s, blocks, l) -> STC_Program(s, out_blocks, l)
	  where
    	(errors, out_blocks) := <unzip><mapconcat(stack-calc)> blocks
  
	stack-calc: f@STC_PseudoCode(body) -> [([], f)]

  	stack-calc: STC_Block(FVM_Label(lbl), STC_Seq(body)) -> [(errors, STC_Block(FVM_Label(lbl), STC_Seq(body), size))]
  	  where
  		(size, errors) := <foldl(stack-update)>(body, (0, []))
  
  	stack-update: (instr, (size, err)) -> (new_size, err)
  	  where
  	  	new_size := <addi> (size, <stack-delta> instr);
  	  	_ := <geq> (new_size, 0)
  	  	
  	 stack-update: (instr, (size, errs)) -> (new_size, [err | errs])
  	  where
  	  	new_size := <addi> (size, <stack-delta> instr);
  	  	err := ("Popping from empty stack at", instr)
  	  	
	// For each operation, calculate the change in stack size
	stack-delta: STC_CharPush(_) -> 1
	stack-delta: STC_IPush(_) -> 1
	stack-delta: STC_INeg()   -> 0
	stack-delta: STC_IAdd()   -> -1
	stack-delta: STC_IMul()   -> -1
	stack-delta: STC_ISub()   -> -1
	stack-delta: STC_IDiv()   -> -1
	stack-delta: STC_IMod()   -> -1
	
	stack-delta: STC_IEq()    -> -1
	stack-delta: STC_ILt()    -> -1
	stack-delta: STC_IGt()    -> -1
	stack-delta: STC_IOr()    -> -1
	stack-delta: STC_IXor()   -> -1
	stack-delta: STC_IAnd()   -> -1
  
	stack-delta: STC_New(_)   -> 1
	stack-delta: STC_New()    -> 1
	stack-delta: STC_NewR()   -> 0
	
	stack-delta: STC_Pop()    -> -1
	stack-delta: STC_Dup()    -> 1
	stack-delta: STC_DupN(_)  -> 1
	stack-delta: STC_Swap()   -> 0
	stack-delta: STC_SwapN(_) -> 0
  
	stack-delta: STC_Link(_, _) -> -1
	stack-delta: STC_LinkR(_)   -> -2
	stack-delta: STC_FSize()   -> 0
  
	stack-delta: STC_Get()      -> 0
	stack-delta: STC_Get(path)  -> 1
	stack-delta: STC_GetR()     -> -1
	stack-delta: STC_GetR(path) -> 0
  
	stack-delta: STC_Set()      -> -2
	stack-delta: STC_Set(path)  -> -1
	stack-delta: STC_SetR()     -> -3
	stack-delta: STC_SetR(path) -> -2
	
	stack-delta: STC_ContSet()      -> -2
	stack-delta: STC_ContSet(cont)  -> -1
	stack-delta: STC_ContSetR()     -> -3
	stack-delta: STC_ContSetR(path) -> -2
	
	stack-delta: STC_ContGet()      -> 0
	stack-delta: STC_ContGet(path)  -> 1
	stack-delta: STC_ContGetR()     -> -1
	stack-delta: STC_ContGetR(path) -> 0
	
	stack-delta: STC_ContTransfer(n)    -> <dec> <subti> (0, <string-to-int> n)
	stack-delta: STC_ContTransfer(n, _) -> <subti> (0, <string-to-int> n)
	
	stack-delta: STC_ContRGetN(n) -> <string-to-int> n
	stack-delta: STC_ContRGet()   -> 1
  
	stack-delta: STC_Print()  -> -1
	stack-delta: STC_PrintChar()  -> -1
	stack-delta: STC_Return() -> -1
	stack-delta: STC_ReturnN(n) -> <string-to-int> n
  
	stack-delta: STC_FrameCopy(_)  -> 1
	stack-delta: STC_FrameCopyR(_) -> 0
	stack-delta: STC_ContCopy(_, _)   -> 1
	stack-delta: STC_ContCopyR(_, _)  -> 0
  
	stack-delta: STC_JumpZ(lbl1, lbl2) -> -1
	stack-delta: STC_Jump(lbl) -> 0
	stack-delta: STC_Call(lbl1, lbl2) -> -1
	stack-delta: STC_Call(lbl) -> -1
	stack-delta: STC_TailCall(lbl) -> -1
	stack-delta: STC_TailCall() -> -1
	
	
	stack-delta: STC_ContThis() -> 1
	stack-delta: STC_ContNew(lbl, _) -> 0
	
	stack-delta: STC_ContCall(_) -> -1
	stack-delta: STC_ContReturn() -> -1
	stack-delta: STC_ContReturn(_) -> 0
	
	stack-delta: STC_ScopeNew(_, lbl) -> -1
	stack-delta: STC_ScopeNew(_)    -> -1
	stack-delta: STC_ScopeSetCurrent()    -> -1
	
	stack-delta: STC_ScopeExit(path) -> 0
	stack-delta: STC_ScopeExit(path, lbl) -> 0
	
	stack-delta: STC_Try(_, _, _) -> -2
	stack-delta: STC_Try(_) -> -2
	stack-delta: STC_Throw() -> -1
	stack-delta: STC_Yield(_) -> -1
	
	stack-delta: STC_Debug() -> 0
	stack-delta: STC_DebugKill() -> 0
	
	stack-delta: STC_IsInt()   -> 0
	stack-delta: STC_IsCont()  -> 0
	stack-delta: STC_IsFrame() -> 0
	stack-delta: STC_IsClos() -> 0
	
	stack-delta: STC_ClosNew(_, _) -> 0
	stack-delta: STC_ClosNew(_)    -> 0
	stack-delta: STC_ClosUnpack() -> 0
	
	stack-delta: STC_StringPush(_) -> 1
  
  	stack-delta: a -> 0
  	  where
  		_ := <debug> ("Stack calculations not implemented for", a)
